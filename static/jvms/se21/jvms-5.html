<html lang="zh">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title>Chapter 5. Loading, Linking, and Initializing</title>
    <link rel="stylesheet" type="text/css" href="../res/javaspec.css"/>
</head>

<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div id="logo">
    <img src="../res/oralogo_small.gif" alt="Oracle Logo"/><br/>
    <p>
        <a href="https://docs.oracle.com/en/java/javase/21/">Java SE</a> &gt;
        <a href="https://docs.oracle.com/javase/specs/index.html">Java SE Specifications</a> &gt;
        <a href="./index.html">Java Virtual Machine Specification</a>
    </p>
</div>
<div class="navheader">
    <table width="100%" summary="Navigation header">
        <tbody>
        <tr>
            <th colspan="3" align="center">Chapter 5. Loading, Linking, and Initializing</th>
        </tr>
        <tr>
            <td width="20%" align="left"><a accesskey="p"
                                            href="./jvms-4.html">Prev</a>
            </td>
            <th width="60%" align="center"></th>
            <td width="20%" align="right"><a accesskey="n"
                                             href="./jvms-6.html">Next</a></td>
        </tr>
        </tbody>
    </table>
    <hr/>
</div>
<div lang="en" class="chapter">
    <div class="titlepage">
        <div>
            <div>
                <h1 class="title"><a id="jvms-5"></a>Chapter 5. Loading, Linking, and Initializing
                </h1>
            </div>
        </div>
    </div>
    <div class="toc">
        <p><b>Table of Contents</b></p>
        <dl class="toc">
            <dt><span class="section"><a
                    href="./jvms-5.html#jvms-5.1">5.1. The Run-Time
                     Constant Pool</a></span></dt>
            <dt><span class="section"><a
                    href="./jvms-5.html#jvms-5.2">5.2. Java Virtual
                     Machine Startup</a></span></dt>
            <dt><span class="section"><a
                    href="./jvms-5.html#jvms-5.3">5.3. Creation and
                     Loading</a></span></dt>
            <dd>
                <dl>
                    <dt><span class="section"><a
                            href="./jvms-5.html#jvms-5.3.1">5.3.1.
                           Loading Using the Bootstrap Class Loader</a></span></dt>
                    <dt><span class="section"><a
                            href="./jvms-5.html#jvms-5.3.2">5.3.2.
                           Loading Using a User-defined Class Loader</a></span></dt>
                    <dt><span class="section"><a
                            href="./jvms-5.html#jvms-5.3.3">5.3.3.
                           Creating Array Classes</a></span></dt>
                    <dt><span class="section"><a
                            href="./jvms-5.html#jvms-5.3.4">5.3.4.
                           Loading Constraints</a></span></dt>
                    <dt><span class="section"><a
                            href="./jvms-5.html#jvms-5.3.5">5.3.5.
                           Deriving a Class from a <code class="literal">class</code> File Representation</a></span>
                    </dt>
                    <dt><span class="section"><a
                            href="./jvms-5.html#jvms-5.3.6">5.3.6.
                           Modules and Layers</a></span></dt>
                </dl>
            </dd>
            <dt><span class="section"><a
                    href="./jvms-5.html#jvms-5.4">5.4.
                     Linking</a></span></dt>
            <dd>
                <dl>
                    <dt><span class="section"><a
                            href="./jvms-5.html#jvms-5.4.1">5.4.1.
                           Verification</a></span></dt>
                    <dt><span class="section"><a
                            href="./jvms-5.html#jvms-5.4.2">5.4.2.
                           Preparation</a></span></dt>
                    <dt><span class="section"><a
                            href="./jvms-5.html#jvms-5.4.3">5.4.3.
                           Resolution</a></span></dt>
                    <dd>
                        <dl>
                            <dt><span class="section"><a
                                    href="./jvms-5.html#jvms-5.4.3.1">5.4.3.1.
                                 Class and Interface Resolution</a></span></dt>
                            <dt><span class="section"><a
                                    href="./jvms-5.html#jvms-5.4.3.2">5.4.3.2.
                                 Field Resolution</a></span></dt>
                            <dt><span class="section"><a
                                    href="./jvms-5.html#jvms-5.4.3.3">5.4.3.3.
                                 Method Resolution</a></span></dt>
                            <dt><span class="section"><a
                                    href="./jvms-5.html#jvms-5.4.3.4">5.4.3.4.
                                 Interface Method Resolution</a></span></dt>
                            <dt><span class="section"><a
                                    href="./jvms-5.html#jvms-5.4.3.5">5.4.3.5.
                                 Method Type and Method Handle Resolution</a></span></dt>
                            <dt><span class="section"><a
                                    href="./jvms-5.html#jvms-5.4.3.6">5.4.3.6.
                                 Dynamically-Computed Constant and Call Site Resolution</a></span></dt>
                        </dl>
                    </dd>
                    <dt><span class="section"><a
                            href="./jvms-5.html#jvms-5.4.4">5.4.4.
                           Access Control</a></span></dt>
                    <dt><span class="section"><a
                            href="./jvms-5.html#jvms-5.4.5">5.4.5.
                           Method Overriding</a></span></dt>
                    <dt><span class="section"><a
                            href="./jvms-5.html#jvms-5.4.6">5.4.6.
                           Method Selection</a></span></dt>
                </dl>
            </dd>
            <dt><span class="section"><a
                    href="./jvms-5.html#jvms-5.5">5.5.
                     Initialization</a></span></dt>
            <dt><span class="section"><a
                    href="./jvms-5.html#jvms-5.6">5.6. Binding Native
                     Method Implementations</a></span></dt>
            <dt><span class="section"><a
                    href="./jvms-5.html#jvms-5.7">5.7. Java Virtual
                     Machine Termination</a></span></dt>
        </dl>
    </div>
    <p class="norm"><a id="jvms-5-100"></a>The Java Virtual Machine dynamically loads,
        links and initializes classes and interfaces. Loading is the process
        of finding the binary representation of a class or interface type with
        a particular name and <span class="emphasis"><em>creating</em></span> a class or
        interface from that binary representation. Linking is the process of
        taking a class or interface and combining it into the run-time state
        of the Java Virtual Machine so that it can be executed. Initialization of a class or
        interface consists of executing the class or interface initialization
        method <code class="literal">&lt;clinit&gt;</code> (<a class="xref"
                                                               href="./jvms-2.html#jvms-2.9.2"
                                                               title="2.9.2. Class Initialization Methods">2.9.2</a>).
    </p>
    <p class="norm"><a id="jvms-5-110"></a>In this chapter,
        <a class="xref" href="./jvms-5.html#jvms-5.1"
           title="5.1. The Run-Time Constant Pool">5.1</a> describes how the Java Virtual Machine derives symbolic
        references from the binary representation of a class or
        interface. <a class="xref" href="./jvms-5.html#jvms-5.2"
                      title="5.2. Java Virtual Machine Startup">5.2</a> explains how the processes of
        loading, linking, and initialization are first initiated by the
        Java Virtual Machine. <a class="xref"
                                 href="./jvms-5.html#jvms-5.3"
                                 title="5.3. Creation and Loading">5.3</a> specifies how binary representations
        of classes and interfaces are loaded by class loaders and how classes
        and interfaces are created. Linking is described in
        <a class="xref" href="./jvms-5.html#jvms-5.4"
           title="5.4. Linking">5.4</a>. <a class="xref"
                                            href="./jvms-5.html#jvms-5.5"
                                            title="5.5. Initialization">5.5</a> details how
        classes and interfaces are initialized. <a class="xref"
                                                   href="./jvms-5.html#jvms-5.6"
                                                   title="5.6. Binding Native Method Implementations">5.6</a>
        introduces the notion of binding native methods. Finally,
        <a class="xref" href="./jvms-5.html#jvms-5.7"
           title="5.7. Java Virtual Machine Termination">5.7</a> describes when the Java Virtual Machine terminates.
    </p>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a id="jvms-5.1"></a>5.1. The Run-Time Constant Pool
                    </h2>
                </div>
            </div>
        </div>
        <p class="norm"><a id="jvms-5.1-100"></a>
            The Java Virtual Machine maintains a run-time constant pool for each class and
            interface (<a class="xref" href="./jvms-2.html#jvms-2.5.5"
                          title="2.5.5. Run-Time Constant Pool">2.5.5</a>). This data structure serves
            many of the purposes of the symbol table of a conventional programming
            language implementation. The <code class="literal">constant_pool</code> table in the binary
            representation of a class or interface (<a class="xref"
                                                       href="./jvms-4.html#jvms-4.4"
                                                       title="4.4. The Constant Pool">4.4</a>) is
            used to construct the run-time constant pool upon class or interface
            creation (<a class="xref" href="./jvms-5.html#jvms-5.3"
                         title="5.3. Creation and Loading">5.3</a>).
        </p>
        <p class="norm"><a id="jvms-5.1-110"></a>
            There are two kinds of entry in the run-time constant pool: symbolic
            references, which may later be resolved (<a class="xref"
                                                        href="./jvms-5.html#jvms-5.4.3"
                                                        title="5.4.3. Resolution">5.4.3</a>),
            and static constants, which require no further processing.
        </p>
        <p class="norm"><a id="jvms-5.1-200"></a>
            The symbolic references in the run-time constant pool are derived from
            entries in the <code class="literal">constant_pool</code> table in accordance with the structure of
            each entry:
        </p>
        <div class="norm">
            <ul class="norm" style="list-style-type: disc; ">
                <li class="listitem">
                    <p class="norm"><a id="jvms-5.1-200-A"></a>
                        A symbolic reference to a class or interface is derived from a
                        <code class="literal">CONSTANT_Class_info</code> structure (<a class="xref"
                                                                                       href="./jvms-4.html#jvms-4.4.1"
                                                                                       title="4.4.1. The CONSTANT_Class_info Structure">4.4.1</a>).
                        Such a reference gives the name of the class or interface in the
                        following form:
                    </p>
                    <div class="norm">
                        <ul class="norm" style="list-style-type: circle; ">
                            <li class="listitem">
                                <p class="norm"><a id="jvms-5.1-200-A-A"></a>
                                    For a nonarray class or an interface, the name is the binary
                                    name (<a class="xref"
                                             href="./jvms-4.html#jvms-4.2.1"
                                             title="4.2.1. Binary Class and Interface Names">4.2.1</a>) of the class or
                                    interface.
                                </p>
                            </li>
                            <li class="listitem">
                                <p class="norm"><a id="jvms-5.1-200-A-B"></a>
                                    For an array class of <span class="emphasis"><em>n</em></span> dimensions, the name
                                    begins
                                    with <span class="emphasis"><em>n</em></span> occurrences of the ASCII <code
                                            class="literal">[</code> character
                                    followed by a representation of the element type:
                                </p>
                                <div class="norm">
                                    <ul class="norm" style="list-style-type: square; ">
                                        <li class="listitem">
                                            <p class="norm"><a id="jvms-5.1-200-A-B-A"></a>
                                                If the element type is a primitive type, it is
                                                represented by the corresponding field descriptor
                                                (<a class="xref"
                                                    href="./jvms-4.html#jvms-4.3.2"
                                                    title="4.3.2. Field Descriptors">4.3.2</a>).
                                            </p>
                                        </li>
                                        <li class="listitem">
                                            <p class="norm"><a id="jvms-5.1-200-A-B-B"></a>
                                                Otherwise, if the element type is a reference type, it
                                                is represented by the ASCII <code class="literal">L</code> character
                                                followed by the binary name of the element type followed
                                                by the ASCII <code class="literal">;</code> character.
                                            </p>
                                        </li>
                                    </ul>
                                </div>
                            </li>
                        </ul>
                    </div>
                    <p class="norm"><a id="jvms-5.1-200-A.1"></a>
                        Whenever this chapter refers to the name of a class or
                        interface, the name should be understood to be in the form
                        above. (This is also the form returned by
                        the <code class="literal">Class.getName</code> method.)
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-5.1-200-B"></a>
                        A symbolic reference to a field of a class or an interface is
                        derived from a <code class="literal">CONSTANT_Fieldref_info</code> structure
                        (<a class="xref" href="./jvms-4.html#jvms-4.4.2"
                            title="4.4.2. The CONSTANT_Fieldref_info, CONSTANT_Methodref_info, and CONSTANT_InterfaceMethodref_info Structures">4.4.2</a>).
                        Such a reference gives the name
                        and descriptor of the field, as well as a symbolic reference to
                        the class or interface in which the field is to be found.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-5.1-200-C"></a>
                        A symbolic reference to a method of a class is derived from a
                        <code class="literal">CONSTANT_Methodref_info</code> structure (<a class="xref"
                                                                                           href="./jvms-4.html#jvms-4.4.2"
                                                                                           title="4.4.2. The CONSTANT_Fieldref_info, CONSTANT_Methodref_info, and CONSTANT_InterfaceMethodref_info Structures">4.4.2</a>).
                        Such a reference gives the name and descriptor of the method, as
                        well as a symbolic reference to the class in which the method is
                        to be found.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-5.1-200-D"></a>
                        A symbolic reference to a method of an interface is derived from
                        a <code class="literal">CONSTANT_InterfaceMethodref_info</code> structure
                        (<a class="xref" href="./jvms-4.html#jvms-4.4.2"
                            title="4.4.2. The CONSTANT_Fieldref_info, CONSTANT_Methodref_info, and CONSTANT_InterfaceMethodref_info Structures">4.4.2</a>).
                        Such a reference gives the name
                        and descriptor of the interface method, as well as a symbolic
                        reference to the interface in which the method is to be
                        found.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-5.1-200-E"></a>
                        A symbolic reference to a method handle is derived from a
                        <code class="literal">CONSTANT_MethodHandle_info</code> structure (<a class="xref"
                                                                                              href="./jvms-4.html#jvms-4.4.8"
                                                                                              title="4.4.8. The CONSTANT_MethodHandle_info Structure">4.4.8</a>).
                        Such a reference gives a symbolic reference to a field of a
                        class or interface, or a method of a class, or a method of an
                        interface, depending on the kind of the method handle.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-5.1-200-F"></a>
                        A symbolic reference to a method type is derived from a
                        <code class="literal">CONSTANT_MethodType_info</code> structure (<a class="xref"
                                                                                            href="./jvms-4.html#jvms-4.4.9"
                                                                                            title="4.4.9. The CONSTANT_MethodType_info Structure">4.4.9</a>).
                        Such a reference gives a method descriptor
                        (<a class="xref" href="./jvms-4.html#jvms-4.3.3"
                            title="4.3.3. Method Descriptors">4.3.3</a>).
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-5.1-200-G"></a>
                        A symbolic reference to a <span class="emphasis"><em>dynamically-computed
                           constant</em></span> is derived from a <code class="literal">CONSTANT_Dynamic_info</code>
                        structure (<a class="xref"
                                      href="./jvms-4.html#jvms-4.4.10"
                                      title="4.4.10. The CONSTANT_Dynamic_info and CONSTANT_InvokeDynamic_info Structures">4.4.10</a>).
                        Such a reference gives:
                    </p>
                    <div class="norm">
                        <ul class="norm" style="list-style-type: circle; ">
                            <li class="listitem">
                                <p class="norm"><a id="jvms-5.1-200-G-A"></a>
                                    a symbolic reference to a method handle, which will be
                                    invoked to compute the constant's value;
                                </p>
                            </li>
                            <li class="listitem">
                                <p class="norm"><a id="jvms-5.1-200-G-B"></a>
                                    a sequence of symbolic references and static constants,
                                    which will serve as <span class="emphasis"><em>static arguments</em></span>
                                    when the method handle is invoked;
                                </p>
                            </li>
                            <li class="listitem">
                                <p class="norm"><a id="jvms-5.1-200-G-C"></a>
                                    an unqualified name and a field descriptor.
                                </p>
                            </li>
                        </ul>
                    </div>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-5.1-200-H"></a>
                        A symbolic reference to a <span class="emphasis"><em>dynamically-computed call
                           site</em></span> is derived from a <code class="literal">CONSTANT_InvokeDynamic_info</code>
                        structure (<a class="xref"
                                      href="./jvms-4.html#jvms-4.4.10"
                                      title="4.4.10. The CONSTANT_Dynamic_info and CONSTANT_InvokeDynamic_info Structures">4.4.10</a>).
                        Such a reference gives:
                    </p>
                    <div class="norm">
                        <ul class="norm" style="list-style-type: circle; ">
                            <li class="listitem">
                                <p class="norm"><a id="jvms-5.1-200-H-A"></a>
                                    a symbolic reference to a method handle, which will be
                                    invoked in the course of an <span class="emphasis"><em>invokedynamic</em></span>
                                    instruction
                                    (<a class="xref"
                                        href="./jvms-6.html#jvms-6.5.invokedynamic"
                                        title="invokedynamic"><span class="emphasis"><em>invokedynamic</em></span></a>)
                                    to
                                    compute an
                                    instance of <code class="literal">java.lang.invoke.CallSite</code>;
                                </p>
                            </li>
                            <li class="listitem">
                                <p class="norm"><a id="jvms-5.1-200-H-B"></a>
                                    a sequence of symbolic references and static constants,
                                    which will serve as <span class="emphasis"><em>static arguments</em></span>
                                    when the method handle is invoked;
                                </p>
                            </li>
                            <li class="listitem">
                                <p class="norm"><a id="jvms-5.1-200-H-C"></a>
                                    an unqualified name and a method descriptor.
                                </p>
                            </li>
                        </ul>
                    </div>
                </li>
            </ul>
        </div>
        <p class="norm"><a id="jvms-5.1-300"></a>
            The static constants in the run-time constant pool are also derived
            from entries in the <code class="literal">constant_pool</code> table in accordance with the
            structure of each entry:
        </p>
        <div class="norm">
            <ul class="norm" style="list-style-type: disc; ">
                <li class="listitem">
                    <p class="norm"><a id="jvms-5.1-300-A"></a>
                        A string constant is a <code class="literal">reference</code> to an instance of class <code
                                class="literal">String</code>,
                        and is derived from a <code class="literal">CONSTANT_String_info</code> structure
                        (<a class="xref" href="./jvms-4.html#jvms-4.4.3"
                            title="4.4.3. The CONSTANT_String_info Structure">4.4.3</a>). To derive a string constant,
                        the
                        Java Virtual Machine examines the sequence of code points given by the
                        <code class="literal">CONSTANT_String_info</code> structure:
                    </p>
                    <div class="norm">
                        <ul class="norm" style="list-style-type: circle; ">
                            <li class="listitem">
                                <p class="norm"><a id="jvms-5.1-300-A-A"></a>
                                    If the method <code class="literal">String.intern</code> has previously been invoked
                                    on an
                                    instance of class <code class="literal">String</code> containing a sequence of
                                    Unicode
                                    code points identical to that given by the
                                    <code class="literal">CONSTANT_String_info</code> structure, then the string
                                    constant
                                    is a <code class="literal">reference</code> to that same instance of class <code
                                            class="literal">String</code>.
                                </p>
                            </li>
                            <li class="listitem">
                                <p class="norm"><a id="jvms-5.1-300-A-B"></a>
                                    Otherwise, a new instance of class <code class="literal">String</code> is created
                                    containing the sequence of Unicode code points given by the
                                    <code class="literal">CONSTANT_String_info</code> structure. The string constant is
                                    a
                                    <code class="literal">reference</code> to the new instance. Finally, the method
                                    <code
                                            class="literal">String.intern</code> is
                                    invoked on the new instance.
                                </p>
                            </li>
                        </ul>
                    </div>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-5.1-300-B"></a>
                        Numeric constants are derived from <code class="literal">CONSTANT_Integer_info</code>,
                        <code class="literal">CONSTANT_Float_info</code>, <code
                                class="literal">CONSTANT_Long_info</code>,
                        and
                        <code class="literal">CONSTANT_Double_info</code> structures (<a class="xref"
                                                                                         href="./jvms-4.html#jvms-4.4.4"
                                                                                         title="4.4.4. The CONSTANT_Integer_info and CONSTANT_Float_info Structures">4.4.4</a>,
                        <a class="xref" href="./jvms-4.html#jvms-4.4.5"
                           title="4.4.5. The CONSTANT_Long_info and CONSTANT_Double_info Structures">4.4.5</a>).
                    </p>
                    <p class="norm"><a id="jvms-5.1-300-B.1"></a>
                        Note that <code class="literal">CONSTANT_Float_info</code> structures represent values in
                        IEEE 754 single format and <code class="literal">CONSTANT_Double_info</code> structures
                        represent values in IEEE 754 double format. The numeric
                        constants derived from these structures must thus be values that
                        can be represented using IEEE 754 single and double formats,
                        respectively.
                    </p>
                </li>
            </ul>
        </div>
        <p class="norm"><a id="jvms-5.1-400"></a>
            The remaining structures in the <code class="literal">constant_pool</code> table - the
            descriptive structures <code class="literal">CONSTANT_NameAndType_info</code>,
            <code class="literal">CONSTANT_Module_info</code>, and <code class="literal">CONSTANT_Package_info</code>,
            and the
            foundational structure <code class="literal">CONSTANT_Utf8_info</code> - are only used indirectly
            when constructing the run-time constant pool. No entries in the
            run-time constant pool correspond directly to these structures.
        </p>
        <p class="norm"><a id="jvms-5.1-500"></a>
            Some entries in the run-time constant pool are
            <span class="emphasis"><em>loadable</em></span>, which means:
        </p>
        <div class="norm">
            <ul class="norm" style="list-style-type: disc; ">
                <li class="listitem">
                    <p class="norm"><a id="jvms-5.1-500-A"></a>
                        They may be pushed onto the stack by the <span class="emphasis"><em>ldc</em></span> family of
                        instructions (<a class="xref"
                                         href="./jvms-6.html#jvms-6.5.ldc"
                                         title="ldc"><span class="emphasis"><em>ldc</em></span></a>,
                        <a class="xref"
                           href="./jvms-6.html#jvms-6.5.ldc_w"
                           title="ldc_w"><span class="emphasis"><em>ldc_w</em></span></a>, <a class="xref"
                                                                                              href="./jvms-6.html#jvms-6.5.ldc2_w"
                                                                                              title="ldc2_w"><span
                                class="emphasis"><em>ldc2_w</em></span></a>).
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-5.1-500-B"></a>
                        They may be static arguments to bootstrap methods for
                        dynamically-computed constants and call sites
                        (<a class="xref"
                            href="./jvms-5.html#jvms-5.4.3.6"
                            title="5.4.3.6. Dynamically-Computed Constant and Call Site Resolution">5.4.3.6</a>).
                    </p>
                </li>
            </ul>
        </div>
        <p class="norm"><a id="jvms-5.1-510"></a>
            An entry in the run-time constant pool is loadable if it is derived
            from an entry in the <code class="literal">constant_pool</code> table that is loadable
            (see <a class="xref" href="./jvms-4.html#jvms-4.4-310"
                    title="Table 4.4-C. Loadable constant pool tags">Table 4.4-C</a>). Accordingly, the following
            entries in
            the run-time constant pool are loadable:
        </p>
        <div class="norm">
            <ul class="norm" style="list-style-type: disc; ">
                <li class="listitem">
                    <p class="norm"><a id="jvms-5.1-510-A"></a>
                        Symbolic references to classes and interfaces
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-5.1-510-B"></a>
                        Symbolic references to method handles
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-5.1-510-C"></a>
                        Symbolic references to method types
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-5.1-510-D"></a>
                        Symbolic references to dynamically-computed constants
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-5.1-510-E"></a>
                        Static constants
                    </p>
                </li>
            </ul>
        </div>
    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a id="jvms-5.2"></a>5.2. Java Virtual Machine Startup
                    </h2>
                </div>
            </div>
        </div>
        <p class="norm"><a id="jvms-5.2-100"></a>

            The Java Virtual Machine starts up by creating an initial class or interface using
            the bootstrap class loader (<a class="xref"
                                           href="./jvms-5.html#jvms-5.3.1"
                                           title="5.3.1. Loading Using the Bootstrap Class Loader">5.3.1</a>) or a
            user-defined class loader (<a class="xref"
                                          href="./jvms-5.html#jvms-5.3.2"
                                          title="5.3.2. Loading Using a User-defined Class Loader">5.3.2</a>). The Java
            Virtual Machine
            then links the initial class or interface, initializes it, and invokes
            the <code class="literal">public</code> <code class="literal">static</code> method <code
                    class="literal">void main(String[])</code>.
            The invocation of this method drives all further execution. Execution
            of the Java Virtual Machine instructions constituting the <code class="literal">main</code>
            method may cause linking (and consequently creation) of additional
            classes and interfaces, as well as invocation of additional
            methods.
        </p>
        <p class="norm"><a id="jvms-5.2-110"></a>
            The initial class or interface is specified in an
            implementation-dependent manner. For example, the initial class or
            interface could be provided as a command line argument. Alternatively,
            the implementation of the Java Virtual Machine could itself provide an initial class
            that sets up a class loader which in turn loads an application. Other
            choices of the initial class or interface are possible so long as they
            are consistent with the specification given in the previous
            paragraph.
        </p>
    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a id="jvms-5.3"></a>5.3. Creation and Loading
                    </h2>
                </div>
            </div>
        </div>
        <p class="norm"><a id="jvms-5.3-100"></a>
            Creation of a class or interface <span class="type">C</span> denoted by the name <code
                    class="varname">N</code> consists
            of the construction of an implementation-specific internal
            representation of <span class="type">C</span> in the method area of the Java Virtual Machine (<a
                    class="xref" href="./jvms-2.html#jvms-2.5.4"
                    title="2.5.4. Method Area">2.5.4</a>).
        </p>
        <p class="norm"><a id="jvms-5.3-110"></a>
            Class or interface creation is triggered by another class or interface
            <span class="type">D</span>, whose run-time constant pool symbolically references <span
                    class="type">C</span> by means
            of the name <code class="varname">N</code> (<a class="xref"
                                                           href="./jvms-5.html#jvms-5.4.3.1"
                                                           title="5.4.3.1. Class and Interface Resolution">5.4.3.1</a>).
            If <code class="varname">N</code> does not
            denote an array class, then the Java Virtual Machine relies on a <span class="emphasis"><em>class
                  loader</em></span> to locate a binary representation for a class or
            interface called <code class="varname">N</code> (<a class="xref"
                                                                href="./jvms-4.html#jvms-4.1"
                                                                title="4.1. The ClassFile Structure">4.1</a>). Once a
            class loader
            has located a binary representation, it relies in turn on the Java Virtual Machine to
            derive the class or interface <span class="type">C</span> from the binary representation, and
            then to create <span class="type">C</span> in the method area. Array classes do not have an
            external binary representation; they are created by the Java Virtual Machine
            via a different process.
        </p>
        <p class="note">Class or interface creation may also be triggered by
            <span class="type">D</span> invoking methods in certain Java SE Platform class libraries (<a class="xref"
                                                                                                         href="./jvms-2.html#jvms-2.12"
                                                                                                         title="2.12. Class Libraries">2.12</a>)
            such as reflection.
        </p>
        <p class="norm"><a id="jvms-5.3-200"></a>There are two kinds of class
            loaders: the bootstrap class loader supplied by the Java Virtual Machine, and
            user-defined class loaders. Every user-defined class loader is an
            instance of a subclass of the abstract class
            <code class="literal">ClassLoader</code>. Applications employ user-defined class loaders in order
            to extend the manner in which the Java Virtual Machine dynamically creates classes. User-defined class
            loaders can be used
            to
            create classes that originate from user-defined sources. For example,
            a class could be downloaded across a network, generated on the fly, or
            extracted from an encrypted file.
        </p>
        <p class="norm"><a id="jvms-5.3-210"></a>
            When the Java Virtual Machine asks a class loader <code class="varname">L</code> to locate a binary
            representation for a class or interface called <code class="varname">N</code>, <code
                    class="varname">L</code>
            <span class="emphasis"><em>loads</em></span> the class or interface <span class="type">C</span> denoted by
            <code class="varname">N</code>. <code class="varname">L</code> may load <span class="type">C</span>
            directly, by locating a binary
            representation and asking the Java Virtual Machine to derive and create <span class="type">C</span> from the
            binary representation. Alternatively, <code class="varname">L</code> may load <span class="type">C</span>
            indirectly, by
            delegating to another class loader which loads <span class="type">C</span> directly or
            indirectly.
        </p>
        <p class="norm"><a id="jvms-5.3-220"></a>
            If <code class="varname">L</code> loads <span class="type">C</span> directly, we say that <code
                    class="varname">L</code>
            <span class="emphasis"><em>defines</em></span> <span class="type">C</span> or, equivalently, that <code
                    class="varname">L</code> is the
            <span class="emphasis"><em>defining loader</em></span> of <span class="type">C</span>.
        </p>
        <p class="norm"><a id="jvms-5.3-230"></a>
            Whether <code class="varname">L</code> loads <span class="type">C</span> directly or indirectly, we say that
            <code class="varname">L</code>
            <span class="emphasis"><em>initiates</em></span> loading of <span class="type">C</span>, or, equivalently,
            that
            <code class="varname">L</code> is an <span class="emphasis"><em>initiating loader</em></span> of <span
                    class="type">C</span>.
        </p>
        <p class="norm"><a id="jvms-5.3-240"></a>
            Due to class loader delegation, the loader <code class="varname">L<sub>1</sub></code> that initiates loading
            at the Java Virtual Machine's request may not be the same as the loader <code
                    class="varname">L<sub>2</sub></code> that
            completes loading by defining the class or interface. In this case, we
            say that each of <code class="varname">L<sub>1</sub></code> and <code class="varname">L<sub>2</sub></code>
            <span class="emphasis"><em>initiates</em></span> loading
            of <span class="type">C</span>, or, equivalently, that each of <code class="varname">L<sub>1</sub></code>
            and <code class="varname">L<sub>2</sub></code> is an
            <span class="emphasis"><em>initiating loader</em></span> of <span class="type">C</span>. Any loaders in a
            delegation chain between <code class="varname">L<sub>1</sub></code> and <code
                    class="varname">L<sub>2</sub></code> are not considered to be
            initiating loaders of <span class="type">C</span>.
        </p>
        <p class="norm"><a id="jvms-5.3-300"></a>We will sometimes represent a
            class or interface using the following notation, instead of using an
            identifier like <span class="type">C</span> or <span class="type">D</span>:
        </p>
        <div class="norm">
            <ul class="norm" style="list-style-type: disc; ">
                <li class="listitem">
                    <p class="norm"><a id="jvms-5.3-300-A"></a>
                        <code class="literal">&lt;</code><code class="varname">N</code>, <code
                                class="varname">L<sub>d</sub></code><code class="literal">&gt;</code> - where <code
                                class="varname">N</code> denotes the name of the
                        class or interface and <code class="varname">L<sub>d</sub></code> denotes the defining loader
                        of the class or interface.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-5.3-300-B"></a>
                        <code class="varname">N</code><sup><code class="varname">L<sub>i</sub></code></sup> - where
                        <code
                                class="varname">N</code> denotes the name
                        of the class or interface and <code class="varname">L<sub>i</sub></code> denotes an initiating
                        loader
                        of the class or interface.
                    </p>
                </li>
            </ul>
        </div>
        <p class="note">
            It should be clear that <span class="emphasis"><em>loading</em></span> a class or
            interface is a joint effort between the Java Virtual Machine and a class loader (or
            multiple class loaders, if delegation occurs). The ultimate outcome of
            loading is that the Java Virtual Machine creates a class or interface in its method
            area, so it is often convenient to say that a class or interface is
            <span class="emphasis"><em>loaded and thereby created</em></span>.
        </p>
        <p class="note">
            The complex back-and-forth nature of loading, combined with the
            ability of user-defined class loaders to exhibit arbitrary behavior,
            means that exceptions can be thrown <span class="emphasis"><em>after</em></span> the
            Java Virtual Machine has created a class or interface but <span class="emphasis"><em>before</em></span>
            every class loader participating in loading has completed. This
            specification accounts for such exceptions in what is often referred
            to <span class="emphasis"><em>the process of loading and creating a class or
                  interface</em></span>.
        </p>
        <p class="norm"><a id="jvms-5.3-400"></a>The Java Virtual Machine uses one of three
            procedures to create a class or interface <span class="type">C</span> denoted by the name <code
                    class="varname">N</code>
            in the run-time constant pool of a class or interface <span class="type">D</span>:
        </p>
        <div class="norm">
            <ul class="norm" style="list-style-type: disc; ">
                <li class="listitem">
                    <p class="norm"><a id="jvms-5.3-400-A"></a>
                        If <code class="varname">N</code> denotes either a nonarray class or an interface,
                        and <span class="type">D</span> was defined by the bootstrap class loader,
                        then the bootstrap class loader initiates
                        loading of <span class="type">C</span> (<a class="xref"
                                                                   href="./jvms-5.html#jvms-5.3.1"
                                                                   title="5.3.1. Loading Using the Bootstrap Class Loader">5.3.1</a>).
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-5.3-400-B"></a>
                        If <code class="varname">N</code> denotes either a nonarray class or an interface,
                        and <span class="type">D</span> was defined by a user-defined class loader,
                        then that same user-defined class loader initiates
                        loading of <span class="type">C</span> (<a class="xref"
                                                                   href="./jvms-5.html#jvms-5.3.2"
                                                                   title="5.3.2. Loading Using a User-defined Class Loader">5.3.2</a>).
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-5.3-400-C"></a>
                        If <code class="varname">N</code> denotes an array class, then the Java Virtual Machine creates
                        an
                        array
                        class <span class="type">C</span> denoted by <code class="varname">N</code>, in association with
                        the defining
                        loader of <span class="type">D</span> (<a class="xref"
                                                                  href="./jvms-5.html#jvms-5.3.3"
                                                                  title="5.3.3. Creating Array Classes">5.3.3</a>).
                    </p>
                    <p class="note">
                        Although the defining loader of <span class="type">D</span> is relevant in the course of
                        creating an array class, it is not used to load and thereby
                        create the array class.
                    </p>
                </li>
            </ul>
        </div>
        <p class="norm-error"><a id="jvms-5.3-500"></a>If an error
            occurs during loading of a class or interface - either when a class
            loader is locating a binary representation, or when the Java Virtual Machine is
            deriving and creating a class from it - then the error must be thrown at a point in the program
            that (directly or indirectly) uses the class or interface being
            loaded.
        </p>
        <p class="note">A well-behaved class loader should maintain three
            properties:
        </p>
        <div class="note">
            <ul class="note" style="list-style-type: disc; ">
                <li class="listitem">
                    <p class="note">Given the same name, a good class loader should
                        always return the same <code class="literal">Class</code> object.
                    </p>
                </li>
                <li class="listitem">
                    <p class="note">If a class loader <code class="varname">L<sub>1</sub></code> delegates loading of a
                        class <span class="type">C</span> to another loader <code class="varname">L<sub>2</sub></code>,
                        then for any type <span class="type">T</span> that
                        occurs as the direct superclass or a direct superinterface of <span class="type">C</span>,
                        or as the type of a field in <span class="type">C</span>, or as the type of a formal
                        parameter of a method or constructor in <span class="type">C</span>, or as a return type
                        of a method in <span class="type">C</span>, <code class="varname">L<sub>1</sub></code> and <code
                                class="varname">L<sub>2</sub></code> should return the same <code
                                class="literal">Class</code>
                        object.
                    </p>
                </li>
                <li class="listitem">
                    <p class="note">If a user-defined classloader prefetches binary
                        representations of classes and interfaces, or loads a group of
                        related classes together, then it must reflect loading errors only
                        at points in the program where they could have arisen without
                        prefetching or group loading.
                    </p>
                </li>
            </ul>
        </div>
        <p class="norm"><a id="jvms-5.3-600"></a> After
            creation, a class or interface is determined not by its name alone,
            but by a pair: its binary name (<a class="xref"
                                               href="./jvms-4.html#jvms-4.2.1"
                                               title="4.2.1. Binary Class and Interface Names">4.2.1</a>) and its
            defining loader. Each such class or interface belongs to a single
            <span class="emphasis"><em>run-time package</em></span>. The run-time package of a class
            or interface is determined by the package name and the defining loader
            of the class or interface.
        </p>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-5.3.1"></a>5.3.1. Loading Using the Bootstrap Class Loader
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-5.3.1-100"></a>The process of loading and
                creating the nonarray class or interface <span class="type">C</span> denoted by <code
                        class="varname">N</code> using the
                bootstrap class loader is as follows.
            </p>
            <p class="norm"><a id="jvms-5.3.1-110"></a>First, the Java Virtual Machine determines
                whether the bootstrap class loader has already been recorded as an
                initiating loader of a class or interface denoted by <code class="varname">N</code>. If so, this
                class or interface is <span class="type">C</span>, and no class loading or creation is
                necessary.
            </p>
            <p class="norm"><a id="jvms-5.3.1-120"></a>Otherwise, the Java Virtual Machine passes
                the argument <code class="varname">N</code> to an invocation of a method on the bootstrap class
                loader. To load <span class="type">C</span>, the bootstrap class loader locates a purported
                representation of <span class="type">C</span> in a platform-dependent manner, then asks the
                Java Virtual Machine to derive a class or interface <span class="type">C</span> denoted by <code
                        class="varname">N</code> from the
                purported representation using the bootstrap class loader, and then to
                create <span class="type">C</span>, via the algorithm of <a class="xref"
                                                                            href="./jvms-5.html#jvms-5.3.5"
                                                                            title="5.3.5. Deriving a Class from a class File Representation">5.3.5</a>.
            </p>
            <p class="note">Typically, a class or interface will be represented
                using a file in a hierarchical file system, and the name of the class
                or interface will be encoded in the pathname of the file to aid in
                locating it.
            </p>
            <p class="norm-error"><a id="jvms-5.3.1-200"></a>
                If no purported representation of <span class="type">C</span> is found, the bootstrap class loader
                throws a <code class="literal">ClassNotFoundException</code>. The process of loading and creating <span
                        class="type">C</span> then fails
                with a <code class="literal">NoClassDefFoundError</code> whose cause is the <code
                        class="literal">ClassNotFoundException</code>.
            </p>
            <p class="norm-error"><a id="jvms-5.3.1-210"></a>
                If a purported representation of <span class="type">C</span> is found, but deriving <span
                        class="type">C</span> from
                the purported representation fails, then the process of loading
                and creating <span class="type">C</span> fails for the same reason.
            </p>
            <p class="norm-error"><a id="jvms-5.3.1-220"></a>
                Otherwise, the process of loading and creating <span class="type">C</span> succeeds.
            </p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-5.3.2"></a>5.3.2. Loading Using a User-defined Class Loader
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-5.3.2-100"></a>The process of loading and
                creating the nonarray class or interface <span class="type">C</span> denoted by <code
                        class="varname">N</code> using a
                user-defined class loader <code class="varname">L</code> is as follows.
            </p>
            <p class="norm"><a id="jvms-5.3.2-110"></a>First, the Java Virtual Machine determines
                whether <code class="varname">L</code> has already been recorded as an initiating loader of a
                class or interface denoted by <code class="varname">N</code>. If so, this class or interface is
                <span class="type">C</span>, and no class loading or creation is necessary.
            </p>
            <p class="norm"><a id="jvms-5.3.2-120"></a>Otherwise, the Java Virtual Machine invokes
                the <code class="literal">loadClass</code> method of class <code class="literal">ClassLoader</code> on
                <code class="varname">L</code>, passing the name
                <code class="varname">N</code> of a class or interface. <code class="varname">L</code> must perform one
                of the following two
                operations to load and thereby create a class or interface <span class="type">C</span>:
            </p>
            <div class="orderedlist">
                <ol class="orderedlist" type="1">
                    <li class="listitem">
                        <p class="norm"><a id="jvms-5.3.2-130-A"></a>The class loader <code class="varname">L</code>
                            can load <span class="type">C</span> directly. This is accomplished by obtaining an array
                            of bytes that purports to represent <span class="type">C</span> as a
                            <code class="literal">ClassFile</code> structure (<a class="xref"
                                                                                 href="./jvms-4.html#jvms-4.1"
                                                                                 title="4.1. The ClassFile Structure">4.1</a>),
                            and then
                            invoking the method <code class="literal">defineClass</code> of class <code
                                    class="literal">ClassLoader</code>. Invoking
                            <code class="literal">defineClass</code> causes the Java Virtual Machine to derive a class
                            or
                            interface <span class="type">C</span>
                            denoted by <code class="varname">N</code> from the array of bytes using <code
                                    class="varname">L</code>, and then to
                            create <span class="type">C</span>, via the algorithm of <a class="xref"
                                                                                        href="./jvms-5.html#jvms-5.3.5"
                                                                                        title="5.3.5. Deriving a Class from a class File Representation">5.3.5</a>.
                            <code class="varname">L</code> should use the result of <code
                                    class="literal">defineClass</code>
                            as the result
                            of <code class="literal">loadClass</code>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-5.3.2-130-B"></a>The class loader <code class="varname">L</code>
                            can load <span class="type">C</span> indirectly, by delegating the loading of <span
                                    class="type">C</span> to some
                            other class loader <code class="varname">L</code>'. This is accomplished by passing the
                            argument <code class="varname">N</code> to an invocation of a method on <code
                                    class="varname">L</code>' (typically the
                            <code class="literal">loadClass</code> method of class <code
                                    class="literal">ClassLoader</code>). <code class="varname">L</code> should use the
                            result of that method as the result of <code class="literal">loadClass</code>.
                        </p>
                    </li>
                </ol>
            </div>
            <p class="norm-error"><a id="jvms-5.3.2-200"></a>The
                following rules apply regardless of which operation is performed:
            </p>
            <div class="norm">
                <ul class="norm" style="list-style-type: disc; ">
                    <li class="listitem">
                        <p class="norm-error"><a id="jvms-5.3.2-200-A"></a>
                            If a class loader cannot find
                            a purported representation of a class or interface denoted by <code class="varname">N</code>,
                            it
                            must throw a <code class="literal">ClassNotFoundException</code>. The process of loading and
                            creating
                            <span class="type">C</span> then fails with a <code
                                    class="literal">NoClassDefFoundError</code>
                            whose cause is the <code class="literal">ClassNotFoundException</code>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm-error"><a id="jvms-5.3.2-200-B"></a>
                            If a class loader finds a purported representation of <span class="type">C</span>, but
                            deriving <span class="type">C</span> from the purported representation fails, then the
                            process of loading and creating <span class="type">C</span> fails for the same reason.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm-error"><a id="jvms-5.3.2-200-C"></a>
                            If a class loader throws an exception other than a <code
                                    class="literal">ClassNotFoundException</code>,
                            then the process of loading and creating <span class="type">C</span> fails for the
                            same reason.
                        </p>
                    </li>
                </ul>
            </div>
            <p class="norm-error"><a id="jvms-5.3.2-300"></a>
                If the invocation of <code class="literal">loadClass</code> on <code class="varname">L</code> has a
                result, then:
            </p>
            <div class="norm">
                <ul class="norm" style="list-style-type: disc; ">
                    <li class="listitem">
                        <p class="norm-error"><a id="jvms-5.3.2-300-A"></a>
                            If the result is <code class="literal">null</code>, or the result is a class or interface
                            with a name other than <code class="varname">N</code>, then the result is discarded,
                            and the process of loading and creation fails with a <code
                                    class="literal">NoClassDefFoundError</code>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm-dynamic"><a id="jvms-5.3.2-300-B"></a>
                            Otherwise, the result is the created class or interface <span class="type">C</span>.
                            The Java Virtual Machine records that <code class="varname">L</code> is an initiating loader
                            of
                            <span class="type">C</span> (<a class="xref"
                                                            href="./jvms-5.html#jvms-5.3.4"
                                                            title="5.3.4. Loading Constraints">5.3.4</a>). The process
                            of loading and creating <span
                                    class="type">C</span>
                            succeeds.
                        </p>
                    </li>
                </ul>
            </div>
            <p class="note">Since JDK 1.1, Oracles Java Virtual Machine implementation has
                invoked the one-argument <code class="literal">loadClass</code> method on a class loader to cause
                it to load a class or interface. The argument to <code class="literal">loadClass</code> is the
                name of the class or interface to be loaded. There is also a
                two-argument version of the <code class="literal">loadClass</code> method, where the second
                argument is a <code class="literal">boolean</code> that indicates whether the class or interface
                is to be linked or not. Only the two-argument version was supplied in
                JDK 1.0.2, and Oracles Java Virtual Machine implementation relied on it to link the
                loaded class or interface. From JDK 1.1 onward, Oracles Java Virtual Machine
                implementation links the class or interface directly, without relying
                on the class loader.
            </p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-5.3.3"></a>5.3.3. Creating Array Classes
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-5.3.3-100"></a>
                The following steps are used to create the array class <span class="type">C</span>
                denoted by the name <code class="varname">N</code> in association with the class loader <code
                        class="varname">L</code>.
                <code class="varname">L</code> may be either the bootstrap class loader or a user-defined
                class loader.
            </p>
            <p class="norm"><a id="jvms-5.3.3-110"></a>
                First, the Java Virtual Machine determines whether <code class="varname">L</code> has already been
                recorded as an
                initiating loader of an array class with the same component type as <code class="varname">N</code>.
                If so, this class is <span class="type">C</span>, and no array class creation is necessary.
            </p>
            <p class="norm"><a id="jvms-5.3.3-120"></a>
                Otherwise, the following steps are performed to create <span class="type">C</span>:
            </p>
            <div class="orderedlist">
                <ol class="orderedlist" type="1">
                    <li class="listitem">
                        <p class="norm"><a id="jvms-5.3.3-120-A"></a>
                            If the component type is a <code class="literal">reference</code> type, the algorithm of
                            this
                            section (<a class="xref"
                                        href="./jvms-5.html#jvms-5.3"
                                        title="5.3. Creation and Loading">5.3</a>) is applied recursively
                            using <code class="varname">L</code> in order to load and thereby create the component type
                            of <span class="type">C</span>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-5.3.3-120-B"></a>
                            The Java Virtual Machine creates a new array class with the indicated component
                            type and number of dimensions.
                        </p>
                        <p class="norm"><a id="jvms-5.3.3-120-B.1"></a>
                            If the component type is a <code class="literal">reference</code> type, the Java Virtual
                            Machine
                            marks <span class="type">C</span>
                            to have the defining loader of the component type as its
                            defining loader. Otherwise, the Java Virtual Machine marks <span class="type">C</span> to
                            have
                            the
                            bootstrap class loader as its defining loader.
                        </p>
                        <p class="norm"><a id="jvms-5.3.3-120-B.2"></a>
                            In any case, the Java Virtual Machine then records that <code class="varname">L</code> is an
                            initiating
                            loader for <span class="type">C</span> (<a class="xref"
                                                                       href="./jvms-5.html#jvms-5.3.4"
                                                                       title="5.3.4. Loading Constraints">5.3.4</a>).
                        </p>
                        <p class="norm"><a id="jvms-5.3.3-120-B.3"></a>


                            If the component type is a <code class="literal">reference</code> type, the accessibility of
                            the
                            array class is determined by the accessibility of its component
                            type (<a class="xref"
                                     href="./jvms-5.html#jvms-5.4.4"
                                     title="5.4.4. Access Control">5.4.4</a>). Otherwise, the array class
                            is accessible to all classes and interfaces.
                        </p>
                    </li>
                </ol>
            </div>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-5.3.4"></a>5.3.4. Loading Constraints
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-5.3.4-100"></a>
                Ensuring type safe linkage in the presence of class loaders requires
                special care. It is possible that when two different class loaders
                initiate loading of a class or interface denoted by <code class="varname">N</code>, the name <code
                        class="varname">N</code>
                may denote a different class or interface in each loader.
            </p>
            <p class="norm"><a id="jvms-5.3.4-110"></a>
                When a class or interface <span class="type">C</span> = <code class="literal">&lt;</code><code
                        class="varname">N<sub>1</sub></code>, <code class="varname">L<sub>1</sub></code><code
                        class="literal">&gt;</code> makes a
                symbolic reference to a field or method of another class or interface
                <span class="type">D</span> = <code class="literal">&lt;</code><code
                        class="varname">N<sub>2</sub></code>, <code class="varname">L<sub>2</sub></code><code
                        class="literal">&gt;</code>, the symbolic reference includes a
                descriptor specifying the type of the field, or the return and
                argument types of the method. It is essential that any type name <code class="varname">N</code>
                mentioned in the field or method descriptor denote the same class or
                interface when loaded by <code class="varname">L<sub>1</sub></code> and when loaded by <code
                        class="varname">L<sub>2</sub></code>.
            </p>
            <p class="norm-error"><a id="jvms-5.3.4-120"></a>
                To ensure this, the Java Virtual Machine imposes <span class="emphasis"><em>loading
                     constraints</em></span> of the form <code class="varname">N</code><sup><code
                        class="varname">L<sub>1</sub></code></sup>
                = <code class="varname">N</code><sup><code class="varname">L<sub>2</sub></code></sup> during preparation
                (<a class="xref" href="./jvms-5.html#jvms-5.4.2"
                    title="5.4.2. Preparation">5.4.2</a>) and resolution
                (<a class="xref" href="./jvms-5.html#jvms-5.4.3"
                    title="5.4.3. Resolution">5.4.3</a>). To enforce these constraints, the
                Java Virtual Machine will, at certain prescribed times (see
                <a class="xref" href="./jvms-5.html#jvms-5.3.1"
                   title="5.3.1. Loading Using the Bootstrap Class Loader">5.3.1</a>, <a class="xref"
                                                                                         href="./jvms-5.html#jvms-5.3.2"
                                                                                         title="5.3.2. Loading Using a User-defined Class Loader">5.3.2</a>,
                <a class="xref" href="./jvms-5.html#jvms-5.3.3"
                   title="5.3.3. Creating Array Classes">5.3.3</a>, and <a class="xref"
                                                                           href="./jvms-5.html#jvms-5.3.5"
                                                                           title="5.3.5. Deriving a Class from a class File Representation">5.3.5</a>),
                record that a particular loader is an initiating loader of a
                particular class. After recording that a loader is an initiating
                loader of a class, the Java Virtual Machine must immediately check to see if any
                loading constraints are violated. If so, the record is retracted, the
                Java Virtual Machine throws a <code class="literal">LinkageError</code>, and the loading operation that
                caused the
                recording to take place fails.
            </p>
            <p class="norm-error"><a id="jvms-5.3.4-130"></a>
                Similarly, after imposing a loading constraint (see
                <a class="xref" href="./jvms-5.html#jvms-5.4.2"
                   title="5.4.2. Preparation">5.4.2</a>, <a class="xref"
                                                            href="./jvms-5.html#jvms-5.4.3.2"
                                                            title="5.4.3.2. Field Resolution">5.4.3.2</a>,
                <a class="xref" href="./jvms-5.html#jvms-5.4.3.3"
                   title="5.4.3.3. Method Resolution">5.4.3.3</a>, and <a class="xref"
                                                                          href="./jvms-5.html#jvms-5.4.3.4"
                                                                          title="5.4.3.4. Interface Method Resolution">5.4.3.4</a>),
                the Java Virtual Machine must immediately check to see if any loading constraints are
                violated. If so, the newly imposed loading constraint is retracted,
                the Java Virtual Machine throws a <code class="literal">LinkageError</code>, and the operation that
                caused the constraint
                to be imposed (either resolution or preparation, as the case may be)
                fails.
            </p>
            <p class="norm"><a id="jvms-5.3.4-200"></a>
                The situations described here are the only times at which the Java Virtual Machine
                checks whether any loading constraints have been violated. A loading
                constraint is violated if, and only if, all the following four
                conditions hold:
            </p>
            <div class="norm">
                <ul class="norm" style="list-style-type: disc; ">
                    <li class="listitem">
                        <p class="norm"><a id="jvms-5.3.4-200-A"></a>There exists a loader
                            <code class="varname">L</code> such that <code class="varname">L</code> has been recorded by
                            the
                            Java Virtual Machine as an initiating
                            loader of a class <span class="type">C</span> named <code class="varname">N</code>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-5.3.4-200-B"></a>
                            There exists a loader <code class="varname">L</code>' such that <code
                                    class="varname">L</code>'
                            has been recorded by
                            the Java Virtual Machine as an initiating loader of a class <span class="type">C</span> '
                            named
                            <code class="varname">N</code>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-5.3.4-200-C"></a>
                            The equivalence relation defined by the (transitive closure of
                            the) set of imposed constraints implies
                            <code class="varname">N</code><sup><code class="varname">L</code></sup> =
                            <code class="varname">N</code><sup><code class="varname">L</code>'</sup>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-5.3.4-200-D"></a>
                            <span class="type">C</span> <span class="symbol">&#8800;</span> <span class="type">C</span>
                            '.
                        </p>
                    </li>
                </ul>
            </div>
            <p class="note">A full discussion of class loaders and type safety
                is beyond the scope of this specification. For a more comprehensive
                discussion, readers are referred to <em class="citetitle">Dynamic Class Loading
                    in the Java Virtual Machine</em> by Sheng Liang and Gilad
                Bracha (<em class="citetitle">Proceedings of the 1998 ACM SIGPLAN Conference on
                    Object-Oriented Programming Systems, Languages and
                    Applications</em>).
            </p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-5.3.5"></a>5.3.5. Deriving a Class from a <code
                                class="literal">class</code> File Representation
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-5.3.5-100"></a>
                The following steps are used to derive a nonarray class or interface
                <span class="type">C</span> denoted by <code class="varname">N</code> from a purported representation in
                <code class="literal">class</code> file
                format using the class loader <code class="varname">L</code>.
            </p>
            <div class="orderedlist">
                <ol class="orderedlist" type="1">
                    <li class="listitem">
                        <p class="norm-error"><a id="jvms-5.3.5-100-A"></a>
                            First, the Java Virtual Machine determines whether <code class="varname">L</code> has
                            already
                            been
                            recorded as an initiating loader of a class or interface denoted
                            by <code class="varname">N</code>. If so, this derivation attempt is
                            invalid and derivation throws a <code class="literal">LinkageError</code>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-5.3.5-100-B"></a> Otherwise, the Java Virtual Machine
                            attempts to parse the purported representation. The purported
                            representation may not in fact be a valid representation of <span class="type">C</span>,
                            so derivation must detect the following problems:
                        </p>
                        <div class="norm">
                            <ul class="norm" style="list-style-type: disc; ">
                                <li class="listitem">
                                    <p class="norm-error"><a id="jvms-5.3.5-100-B-A"></a>
                                        If the purported representation is not a <code class="literal">ClassFile</code>
                                        structure (<a class="xref"
                                                      href="./jvms-4.html#jvms-4.1"
                                                      title="4.1. The ClassFile Structure">4.1</a>, <a class="xref"
                                                                                                       href="./jvms-4.html#jvms-4.8"
                                                                                                       title="4.8. Format Checking">4.8</a>),
                                        derivation throws a <code
                                                class="literal">ClassFormatError</code>.
                                    </p>
                                </li>
                                <li class="listitem">
                                    <p class="norm-error"><a id="jvms-5.3.5-100-B-B"></a>
                                        Otherwise, if the purported representation is not of a
                                        supported major or minor version (<a class="xref"
                                                                             href="./jvms-4.html#jvms-4.1"
                                                                             title="4.1. The ClassFile Structure">4.1</a>),
                                        derivation throws an <code class="literal">UnsupportedClassVersionError</code>.
                                    </p>
                                    <p class="note"><code class="literal">UnsupportedClassVersionError</code>, a
                                        subclass
                                        of <code class="literal">ClassFormatError</code>, was introduced in JDK 1.2 to
                                        enable
                                        easy
                                        identification of a <code class="literal">ClassFormatError</code> caused by an
                                        attempt
                                        to load a class
                                        whose representation uses an unsupported version of the
                                        <code class="literal">class</code> file format. In JDK 1.1 and earlier, an
                                        instance of
                                        <code class="literal">NoClassDefFoundError</code> or <code
                                                class="literal">ClassFormatError</code> was thrown in case of an
                                        unsupported
                                        version,
                                        depending on whether the class was being loaded by the system
                                        class loader or a user-defined class loader.
                                    </p>
                                </li>
                                <li class="listitem">
                                    <p class="norm-error"><a id="jvms-5.3.5-100-B-C"></a>
                                        Otherwise, if the purported representation does not actually
                                        represent a class or interface named <code class="varname">N</code>, derivation
                                        throws
                                        a <code class="literal">NoClassDefFoundError</code>.
                                    </p>
                                    <p class="norm-error"><a id="jvms-5.3.5-100-B-C.1"></a>
                                        This occurs when the purported representation has either a
                                        <code class="literal">this_class</code> item which specifies a name
                                        other than <code class="varname">N</code>, or an <code
                                                class="literal">access_flags</code> item
                                        which has the <code class="literal">ACC_MODULE</code> flag set.
                                    </p>
                                </li>
                            </ul>
                        </div>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-5.3.5-100-C"></a>
                            If <span class="type">C</span> has a direct superclass, the symbolic reference from <span
                                    class="type">C</span>
                            to its direct superclass is resolved using the algorithm of
                            <a class="xref"
                               href="./jvms-5.html#jvms-5.4.3.1"
                               title="5.4.3.1. Class and Interface Resolution">5.4.3.1</a>. Note that if <span
                                    class="type">C</span> is an interface
                            it must have <code class="literal">Object</code> as its direct superclass, which must
                            already have been loaded. Only <code class="literal">Object</code> has no direct superclass.
                        </p>
                        <p class="norm-error"><a id="jvms-5.3.5-100-C.1"></a>
                            Any exception that can be thrown as a result of failure of class
                            or interface resolution can be thrown as a result of
                            derivation. In addition, derivation must detect the following
                            problems:
                        </p>
                        <div class="norm">
                            <ul class="norm" style="list-style-type: disc; ">
                                <li class="listitem">
                                    <p class="norm-error"><a id="jvms-5.3.5-100-C.1-A"></a>
                                        If any of the superclasses of <span class="type">C</span> is <span
                                                class="type">C</span> itself,
                                        derivation throws a <code class="literal">ClassCircularityError</code>.
                                    </p>
                                </li>
                                <li class="listitem">
                                    <p class="norm-error"><a id="jvms-5.3.5-100-C.1-B"></a>
                                        Otherwise, if the class or interface named as the direct superclass
                                        of <span class="type">C</span> is in fact an interface or a <code
                                                class="literal">final</code> class,
                                        derivation throws an <code class="literal">IncompatibleClassChangeError</code>.
                                    </p>
                                </li>
                                <li class="listitem">
                                    <p class="norm-error"><a id="jvms-5.3.5-100-C.1-C"></a>
                                        Otherwise, if the class named as the direct superclass of
                                        <span class="type">C</span> has a <code
                                                class="literal">PermittedSubclasses</code>
                                        attribute (<a class="xref"
                                                      href="./jvms-4.html#jvms-4.7.31"
                                                      title="4.7.31. The PermittedSubclasses Attribute">4.7.31</a>) and
                                        any of the
                                        following is true,
                                        derivation throws an <code class="literal">IncompatibleClassChangeError</code>:
                                    </p>
                                    <div class="norm">
                                        <ul class="norm" style="list-style-type: circle; ">
                                            <li class="listitem">
                                                <p class="norm-error"><a id="jvms-5.3.5-100-C.1-C-A"></a>
                                                    The superclass is in a different run-time module than <span
                                                            class="type">C</span>
                                                    (<a class="xref"
                                                        href="./jvms-5.html#jvms-5.3.6"
                                                        title="5.3.6. Modules and Layers">5.3.6</a>).

                                                </p>
                                            </li>
                                            <li class="listitem">
                                                <p class="norm-error"><a id="jvms-5.3.5-100-C.1-C-B"></a>
                                                    <span class="type">C</span> does not have its <code
                                                            class="literal">ACC_PUBLIC</code> flag set (<a class="xref"
                                                                                                           href="./jvms-4.html#jvms-4.1"
                                                                                                           title="4.1. The ClassFile Structure">4.1</a>)
                                                    and the superclass is in a
                                                    different run-time package than <span class="type">C</span> (<a
                                                            class="xref"
                                                            href="./jvms-5.html#jvms-5.3"
                                                            title="5.3. Creation and Loading">5.3</a>).
                                                </p>
                                            </li>
                                            <li class="listitem">
                                                <p class="norm-error"><a id="jvms-5.3.5-100-C.1-C-C"></a>
                                                    No entry in the <code class="literal">classes</code> array of the
                                                    superclass's <code class="literal">PermittedSubclasses</code>
                                                    attribute refers
                                                    to a
                                                    class or interface with the name <code class="varname">N</code>.
                                                </p>
                                            </li>
                                        </ul>
                                    </div>
                                </li>
                                <li class="listitem">
                                    <p class="norm-error"><a id="jvms-5.3.5-100-C.1-D"></a>
                                        Otherwise, if <span class="type">C</span> is a class and some instance method
                                        declared in <span class="type">C</span> can override (<a class="xref"
                                                                                                 href="./jvms-5.html#jvms-5.4.5"
                                                                                                 title="5.4.5. Method Overriding">5.4.5</a>)
                                        a <code class="literal">final</code> instance method declared in a superclass of
                                        <span
                                                class="type">C</span>,
                                        derivation throws an <code class="literal">IncompatibleClassChangeError</code>.
                                    </p>
                                </li>
                            </ul>
                        </div>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-5.3.5-100-D"></a>
                            If <span class="type">C</span> has any direct superinterfaces, the symbolic references
                            from <span class="type">C</span> to its direct superinterfaces are resolved using the
                            algorithm of <a class="xref"
                                            href="./jvms-5.html#jvms-5.4.3.1"
                                            title="5.4.3.1. Class and Interface Resolution">5.4.3.1</a>.
                        </p>
                        <p class="norm-error"><a id="jvms-5.3.5-100-D.1"></a>
                            Any exception that can be thrown as a result of failure of class
                            or interface resolution can be thrown as a result of
                            derivation. In addition, derivation must detect the following
                            problems:
                        </p>
                        <div class="norm">
                            <ul class="norm" style="list-style-type: disc; ">
                                <li class="listitem">
                                    <p class="norm-error"><a id="jvms-5.3.5-100-D.1-A"></a>
                                        If any of the superinterfaces of <span class="type">C</span> is <span
                                                class="type">C</span> itself,
                                        derivation throws a <code class="literal">ClassCircularityError</code>.
                                    </p>
                                </li>
                                <li class="listitem">
                                    <p class="norm-error"><a id="jvms-5.3.5-100-D.1-B"></a>
                                        Otherwise, if any class or interface named as a direct
                                        superinterface of <span class="type">C</span> is not in fact an interface,
                                        derivation throws an <code class="literal">IncompatibleClassChangeError</code>.
                                    </p>
                                </li>
                                <li class="listitem">
                                    <p class="norm-error"><a id="jvms-5.3.5-100-D.1-C"></a>
                                        Otherwise, for each direct superinterface named by <span class="type">C</span>,
                                        if
                                        the superinterface has a <code class="literal">PermittedSubclasses</code>
                                        attribute
                                        (<a class="xref"
                                            href="./jvms-4.html#jvms-4.7.31"
                                            title="4.7.31. The PermittedSubclasses Attribute">4.7.31</a>) and any of the
                                        following is
                                        true, derivation throws an <code
                                                class="literal">IncompatibleClassChangeError</code>:
                                    </p>
                                    <div class="norm">
                                        <ul class="norm" style="list-style-type: circle; ">
                                            <li class="listitem">
                                                <p class="norm-error"><a id="jvms-5.3.5-100-D.1-C-A"></a>
                                                    The superinterface is in a different run-time module than <span
                                                            class="type">C</span>.

                                                </p>
                                            </li>
                                            <li class="listitem">
                                                <p class="norm-error"><a id="jvms-5.3.5-100-D.1-C-B"></a>
                                                    <span class="type">C</span> does not have its <code
                                                            class="literal">ACC_PUBLIC</code> flag set (<a class="xref"
                                                                                                           href="./jvms-4.html#jvms-4.1"
                                                                                                           title="4.1. The ClassFile Structure">4.1</a>)
                                                    and the superinterface is in
                                                    a
                                                    different run-time package than <span class="type">C</span>.
                                                </p>
                                            </li>
                                            <li class="listitem">
                                                <p class="norm-error"><a id="jvms-5.3.5-100-D.1-C-C"></a>
                                                    No entry in the <code class="literal">classes</code> array of the
                                                    superinterface's <code class="literal">PermittedSubclasses</code>
                                                    attribute
                                                    refers to a class or interface with the name <code
                                                            class="varname">N</code>.
                                                </p>
                                            </li>
                                        </ul>
                                    </div>
                                </li>
                            </ul>
                        </div>
                    </li>
                </ol>
            </div>
            <p class="norm"><a id="jvms-5.3.5-200"></a>
                If no exception is thrown in steps 1-4, then derivation of the class
                or interface <span class="type">C</span> succeeds. The Java Virtual Machine marks <span
                        class="type">C</span> to have <code class="varname">L</code> as its
                defining loader, records that <code class="varname">L</code> is an initiating loader of <span
                        class="type">C</span>
                (<a class="xref" href="./jvms-5.html#jvms-5.3.4"
                    title="5.3.4. Loading Constraints">5.3.4</a>), and creates <span class="type">C</span> in the method
                area
                (<a class="xref" href="./jvms-2.html#jvms-2.5.4"
                    title="2.5.4. Method Area">2.5.4</a>).
            </p>
            <p class="note">
                When derivation succeeds, the process of loading and creating <span class="type">C</span> is
                not complete until every class loader that was involved in loading <span class="type">C</span>
                (directly or indirectly) returns <span class="type">C</span> as its result. Depending on the
                behavior of user-defined class loaders, the process of loading and
                creating <span class="type">C</span> may yet fail (<a class="xref"
                                                                      href="./jvms-5.html#jvms-5.3.2"
                                                                      title="5.3.2. Loading Using a User-defined Class Loader">5.3.2</a>).
            </p>
            <p class="norm"><a id="jvms-5.3.5-210"></a>
                If an exception is thrown in steps 1-4, then derivation of the class
                or interface <span class="type">C</span> fails with that exception.
            </p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-5.3.6"></a>5.3.6. Modules and Layers
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-5.3.6-100"></a>
                The Java Virtual Machine supports the organization of classes and interfaces into
                modules. The membership of a class or interface <span class="type">C</span> in a module <code
                        class="varname">M</code> is
                used to control access to <span class="type">C</span> from classes and interfaces in modules
                other than <code class="varname">M</code> (<a class="xref"
                                                              href="./jvms-5.html#jvms-5.4.4"
                                                              title="5.4.4. Access Control">5.4.4</a>).
            </p>
            <p class="norm"><a id="jvms-5.3.6-200"></a>
                Module membership is defined in terms of run-time packages
                (<a class="xref" href="./jvms-5.html#jvms-5.3"
                    title="5.3. Creation and Loading">5.3</a>). A program determines the names of the
                packages in each module, and the class loaders that will create the
                classes and interfaces of the named packages; it then specifies the
                packages and class loaders to an invocation of the
                <code class="literal">defineModules</code> method of the class <code class="literal">ModuleLayer</code>.
                Invoking <code class="literal">defineModules</code> causes the Java Virtual Machine to create
                new <span class="emphasis"><em>run-time modules</em></span> that are associated with the
                run-time packages of the class loaders.
            </p>
            <p class="norm"><a id="jvms-5.3.6-210"></a>
                Every run-time module indicates the run-time packages that
                it <span class="emphasis"><em>exports</em></span>, which influences access to the
                <code class="literal">public</code> classes and interfaces in those run-time packages. Every
                run-time module also indicates the other run-time modules that
                it <span class="emphasis"><em>reads</em></span>, which influences access by its own code
                to the <code class="literal">public</code> types and interfaces in those run-time modules.
            </p>
            <p class="norm"><a id="jvms-5.3.6-220"></a>
                We say that <span class="emphasis"><em>a class is in a run-time module</em></span> iff
                the class's run-time package is associated (or will be associated, if
                the class is actually created) with that run-time module.
            </p>
            <p class="norm"><a id="jvms-5.3.6-230"></a>
                A class created by a class loader is in exactly one run-time package
                and therefore exactly one run-time module, because the Java Virtual Machine does not
                support a run-time package being associated with (or more evocatively,
                "split across") multiple run-time modules.
            </p>
            <p class="norm"><a id="jvms-5.3.6-240"></a>
                A run-time module is implicitly bound to exactly one class loader, by
                the semantics of <code class="literal">defineModules</code>. On the other hand,
                a class loader may create classes in more than one run-time module,
                because the Java Virtual Machine does not require all the run-time packages of a
                class loader to be associated with the same run-time module.
            </p>
            <p class="note">In other words, the relationship between class
                loaders and run-time modules need not be 1:1. For a given set of
                modules to be loaded, if a program can determine that the names of the
                packages in each module are found only in that module, then the
                program may specify only one class loader to the invocation
                of <code class="literal">defineModules</code>. This class loader will create
                classes across multiple run-time modules.
            </p>
            <p class="norm"><a id="jvms-5.3.6-300"></a>
                Every run-time module created by <code class="literal">defineModules</code> is
                part of a <span class="emphasis"><em>layer</em></span>. A layer represents a set of
                class loaders that jointly serve to create classes in a set of
                run-time modules. There are two kinds of layers: the boot layer
                supplied by the Java Virtual Machine, and user-defined layers. The boot layer is
                created at Java Virtual Machine startup in an implementation-dependent manner. It
                associates the standard run-time module <code class="literal">java.base</code> with standard
                run-time packages defined by the bootstrap class loader, such as
                <code class="literal">java.lang</code>. User-defined layers are created by programs in order to
                construct sets of run-time modules that depend on <code class="literal">java.base</code> and other
                standard run-time modules.
            </p>
            <p class="norm"><a id="jvms-5.3.6-310"></a>
                A run-time module is implicitly part of exactly one layer, by the
                semantics of <code class="literal">defineModules</code>. However, a class loader
                may create classes in the run-time modules of different layers,
                because the same class loader may be specified to multiple invocations
                of <code class="literal">defineModules</code>. Access control is governed by a
                class's run-time module, not by the class loader which created the
                class or by the layer(s) which the class loader serves.
            </p>
            <p class="norm"><a id="jvms-5.3.6-320"></a>
                The set of class loaders specified for a layer, and the set of
                run-time modules which are part of a layer, are immutable after the
                layer is created. However, the <code class="literal">ModuleLayer</code> class affords programs a
                degree of dynamic control over the relationships between the run-time
                modules in a user-defined layer.
            </p>
            <p class="norm"><a id="jvms-5.3.6-330"></a>
                If a user-defined layer contains more than one class loader, then any
                delegation between the class loaders is the responsibility of the
                program that created the layer. The Java Virtual Machine does not check that the
                layer's class loaders delegate to each other in accordance with how
                the layer's run-time modules read each other. Moreover, if the layer's
                run-time modules are modified via the <code class="literal">ModuleLayer</code> class to read
                additional run-time modules, then the Java Virtual Machine does not check that the
                layer's class loaders are modified by some out-of-band mechanism to
                delegate in a corresponding fashion.
            </p>
            <p class="note">There are similarities and differences between class
                loaders and layers. On the one hand, a layer is similar to a class
                loader in that each may delegate to, respectively, one or more parent
                layers or class loaders that created, respectively, modules or classes
                at an earlier time. That is, the set of modules specified to a layer
                may depend on modules not specified to the layer, and instead
                specified previously to one or more parent layers. On the other hand,
                a layer may be used to create new modules only once, whereas a class
                loader may be used to create new classes or interfaces at any time via
                multiple invocations of the <code class="literal">defineClass</code> method.
            </p>
            <p class="norm"><a id="jvms-5.3.6-400"></a>
                It is possible for a class loader to define a class or interface in a
                run-time package that was not associated with a run-time module by any
                of the layers which the class loader serves. This may occur if the
                run-time package embodies a named package that was not specified
                to <code class="literal">defineModules</code>, or if the class or interface has
                a simple binary name (<a class="xref"
                                         href="./jvms-4.html#jvms-4.2.1"
                                         title="4.2.1. Binary Class and Interface Names">4.2.1</a>) and thus is a
                member of a run-time package that embodies an unnamed package (JLS
                7.4.2). In either case, the class or interface is treated as a member
                of a special run-time module which is implicitly bound to the class
                loader. This special run-time module is known as the <span class="emphasis"><em>unnamed
                     module</em></span> of the class loader. The run-time package of the
                class or interface is associated with the unnamed module of the class
                loader. There are special rules for unnamed modules, designed to
                maximize their interoperation with other run-time modules, as follows:
            </p>
            <div class="norm">
                <ul class="norm" style="list-style-type: disc; ">
                    <li class="listitem">
                        <p class="norm"><a id="jvms-5.3.6-400-A"></a>
                            A class loader's unnamed module is distinct from all other
                            run-time modules bound to the same class loader.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-5.3.6-400-B"></a>
                            A class loader's unnamed module is distinct from all run-time
                            modules (including unnamed modules) bound to other class loaders.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-5.3.6-400-C"></a>
                            Every unnamed module reads every run-time module.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-5.3.6-400-D"></a>
                            Every unnamed module exports, to every run-time module, every
                            run-time package associated with itself.
                        </p>
                    </li>
                </ul>
            </div>
        </div>
    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a id="jvms-5.4"></a>5.4. Linking
                    </h2>
                </div>
            </div>
        </div>
        <p class="norm"><a id="jvms-5.4-100"></a>
            Linking a class or interface involves verifying and preparing that
            class or interface, its direct superclass, its direct superinterfaces,
            and its element type (if it is an array type), if necessary.
            Linking also involves resolution of
            symbolic references in the class or interface, though not necessarily
            at the same time as the class or interface is verified and prepared.
        </p>
        <p class="norm"><a id="jvms-5.4-110"></a>
            This specification allows an implementation flexibility as to when
            linking activities (and, because of recursion, loading) take place,
            provided that all of the following properties are maintained:
        </p>
        <div class="norm">
            <ul class="norm" style="list-style-type: disc; ">
                <li class="listitem">
                    <p class="norm"><a id="jvms-5.4-110-A"></a>
                        A class or interface is completely loaded before it is linked.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-5.4-110-B"></a>
                        A class or interface is completely verified and prepared before
                        it is initialized.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-5.4-110-C"></a>
                        Errors detected during linkage are thrown at a point in the
                        program where some action is taken by the program that might,
                        directly or indirectly, require linkage to the class or
                        interface involved in the error.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-5.4-110-D"></a>
                        A symbolic reference to a dynamically-computed constant is not
                        resolved until either (i) an <span class="emphasis"><em>ldc</em></span>, <span
                                class="emphasis"><em>ldc_w</em></span>, or <span class="emphasis"><em>ldc2_w</em></span>
                        instruction that refers to it is executed, or (ii) a bootstrap
                        method that refers to it as a static argument is invoked.
                    </p>
                    <p class="norm"><a id="jvms-5.4-110-D.1"></a>
                        A symbolic reference to a dynamically-computed call site is not
                        resolved until a bootstrap method that refers to it
                        as a static argument is invoked.
                    </p>
                </li>
            </ul>
        </div>
        <p class="norm"><a id="jvms-5.4-120"></a>
            For example, a Java Virtual Machine implementation may choose a "lazy" linkage
            strategy, where each symbolic reference in a class or interface (other
            than the symbolic references above) is resolved individually when it
            is used. Alternatively, an implementation may choose an "eager"
            linkage strategy, where all symbolic references are resolved at once
            when the class or interface is being verified. This means that the
            resolution process may continue, in some implementations, after a
            class or interface has been initialized. Whichever strategy is
            followed, any error detected during resolution must be thrown at a
            point in the program that (directly or indirectly) uses a symbolic
            reference to the class or interface.
        </p>
        <p class="norm-error"><a id="jvms-5.4-200"></a>
            Because linking involves the allocation of new data structures, it may
            fail with an <code class="literal">OutOfMemoryError</code>.
        </p>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-5.4.1"></a>5.4.1. Verification
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-5.4.1-100"></a>
                <span class="emphasis"><em>Verification</em></span> (<a class="xref"
                                                                        href="./jvms-4.html#jvms-4.10"
                                                                        title="4.10. Verification of class Files">4.10</a>)
                ensures that the binary representation of a class or interface is
                structurally correct (<a class="xref"
                                         href="./jvms-4.html#jvms-4.9"
                                         title="4.9. Constraints on Java Virtual Machine Code">4.9</a>). Verification
                may
                cause additional classes and interfaces to be loaded
                (<a class="xref" href="./jvms-5.html#jvms-5.3"
                    title="5.3. Creation and Loading">5.3</a>) but need not cause them to be verified or
                prepared.
            </p>
            <p class="norm-error"><a id="jvms-5.4.1-110"></a>If the
                binary representation of a class or interface does not satisfy the
                static or structural constraints listed in <a class="xref"
                                                              href="./jvms-4.html#jvms-4.9"
                                                              title="4.9. Constraints on Java Virtual Machine Code">4.9</a>,
                then a <code class="literal">VerifyError</code> must be thrown at the point in the program that caused
                the
                class or interface to be verified.
            </p>
            <p class="norm-error"><a id="jvms-5.4.1-120"></a>If an
                attempt by the Java Virtual Machine to verify a class or interface fails because an
                error is thrown that is an instance of <code class="literal">LinkageError</code> (or a subclass), then
                subsequent attempts to verify the class or interface always fail with
                the same error that was thrown as a result of the initial verification
                attempt.
            </p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-5.4.2"></a>5.4.2. Preparation
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-5.4.2-100"></a>
                <span class="emphasis"><em>Preparation</em></span> involves creating the static fields
                for a class or interface and initializing such fields to their default
                values (<a class="xref" href="./jvms-2.html#jvms-2.3"
                           title="2.3. Primitive Types and Values">2.3</a>, <a class="xref"
                                                                               href="./jvms-2.html#jvms-2.4"
                                                                               title="2.4. Reference Types and Values">2.4</a>).
                This
                does not require the execution of any Java Virtual Machine code; explicit
                initializers for static fields are executed as part of initialization
                (<a class="xref" href="./jvms-5.html#jvms-5.5"
                    title="5.5. Initialization">5.5</a>), not preparation.
            </p>
            <p class="norm"><a id="jvms-5.4.2-110"></a>
                During preparation of a class or interface <span class="type">C</span>, the Java Virtual Machine also
                imposes
                loading constraints (<a class="xref"
                                        href="./jvms-5.html#jvms-5.3.4"
                                        title="5.3.4. Loading Constraints">5.3.4</a>):
            </p>
            <div class="orderedlist">
                <ol class="orderedlist" type="1">
                    <li class="listitem">
                        <p class="norm"><a id="jvms-5.4.2-110-A"></a>
                            Let <code class="varname">L<sub>1</sub></code> be the defining loader of <span
                                    class="type">C</span>. For each instance method
                            <code class="varname">m</code> declared in <span class="type">C</span> that can override (<a
                                    class="xref"
                                    href="./jvms-5.html#jvms-5.4.5"
                                    title="5.4.5. Method Overriding">5.4.5</a>)
                            an instance method declared in a superclass or superinterface
                            <code class="literal">&lt;</code><span class="type">D</span>, <code
                                    class="varname">L<sub>2</sub></code><code class="literal">&gt;</code>, the Java
                            Virtual
                            Machine imposes loading constraints
                            as follows.
                        </p>
                        <p class="norm"><a id="jvms-5.4.2-110-A.1"></a>
                            Given that the return type of <code class="varname">m</code> is <span
                                    class="type">T<sub>r</sub></span>, and that the formal
                            parameter types of <code class="varname">m</code> are <span
                                    class="type">T<sub>f1</sub></span>,
                            ..., <span class="type">T<sub>fn</sub></span>:
                        </p>
                        <p class="norm"><a id="jvms-5.4.2-110-A.2"></a>
                            If <span class="type">T<sub>r</sub></span> not an array type, let <span
                                    class="type">T<sub>0</sub></span> be <span class="type">T<sub>r</sub></span>;
                            otherwise, let
                            <span class="type">T<sub>0</sub></span> be
                            the element type of <span class="type">T<sub>r</sub></span>.
                        </p>
                        <p class="norm"><a id="jvms-5.4.2-110-A.3"></a>
                            For <span class="emphasis"><em>i</em></span> = 1 to <span class="emphasis"><em>n</em></span>:
                            If
                            <span class="type">T<sub>fi</sub></span> is not an array type, let <span
                                    class="type">T<sub>i</sub></span> be
                            <span class="type">T<sub>fi</sub></span>; otherwise, let <span
                                    class="type">T<sub>i</sub></span>
                            be the element type of <span class="type">T<sub>fi</sub></span>.
                        </p>
                        <p class="norm"><a id="jvms-5.4.2-110-A.4"></a>
                            Then <span class="type">T<sub>i</sub></span><sup><code
                                    class="varname">L<sub>1</sub></code></sup> =
                            <span class="type">T<sub>i</sub></span><sup><code class="varname">L<sub>2</sub></code></sup>
                            for
                            <span class="emphasis"><em>i</em></span> = 0 to <span class="emphasis"><em>n</em></span>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-5.4.2-110-B"></a>
                            For each instance method <code class="varname">m</code> declared in a superinterface
                            <code class="literal">&lt;</code><span class="type">I</span>, <code
                                    class="varname">L<sub>3</sub></code><code class="literal">&gt;</code> of <span
                                    class="type">C</span>, if <span class="type">C</span> does not itself declare
                            an instance method that can override <code class="varname">m</code>, then a method is
                            selected (<a class="xref"
                                         href="./jvms-5.html#jvms-5.4.6"
                                         title="5.4.6. Method Selection">5.4.6</a>) with respect to <span
                                    class="type">C</span> and
                            the method <code class="varname">m</code> in <code class="literal">&lt;</code><span
                                    class="type">I</span>, <code class="varname">L<sub>3</sub></code><code
                                    class="literal">&gt;</code>. Let <code class="literal">&lt;</code><span
                                    class="type">D</span>,
                            <code class="varname">L<sub>2</sub></code><code class="literal">&gt;</code> be the class or
                            interface that declares the
                            selected method. The Java Virtual Machine imposes loading constraints as
                            follows.
                        </p>
                        <p class="norm"><a id="jvms-5.4.2-110-B.1"></a>
                            Given that the return type of <code class="varname">m</code> is <span
                                    class="type">T<sub>r</sub></span>, and that the formal
                            parameter types of <code class="varname">m</code> are <span
                                    class="type">T<sub>f1</sub></span>,
                            ..., <span class="type">T<sub>fn</sub></span>:
                        </p>
                        <p class="norm"><a id="jvms-5.4.2-110-B.2"></a>
                            If <span class="type">T<sub>r</sub></span> not an array type, let <span
                                    class="type">T<sub>0</sub></span> be <span class="type">T<sub>r</sub></span>;
                            otherwise, let
                            <span class="type">T<sub>0</sub></span> be
                            the element type of <span class="type">T<sub>r</sub></span>.
                        </p>
                        <p class="norm"><a id="jvms-5.4.2-110-B.3"></a>
                            For <span class="emphasis"><em>i</em></span> = 1 to <span class="emphasis"><em>n</em></span>:
                            If
                            <span class="type">T<sub>fi</sub></span> is not an array type, let <span
                                    class="type">T<sub>i</sub></span> be
                            <span class="type">T<sub>fi</sub></span>; otherwise, let <span
                                    class="type">T<sub>i</sub></span>
                            be the element type of <span class="type">T<sub>fi</sub></span>.
                        </p>
                        <p class="norm"><a id="jvms-5.4.2-110-B.4"></a>
                            Then <span class="type">T<sub>i</sub></span><sup><code
                                    class="varname">L<sub>2</sub></code></sup> =
                            <span class="type">T<sub>i</sub></span><sup><code class="varname">L<sub>3</sub></code></sup>
                            for
                            <span class="emphasis"><em>i</em></span> = 0 to <span class="emphasis"><em>n</em></span>.
                        </p>
                    </li>
                </ol>
            </div>
            <p class="norm"><a id="jvms-5.4.2-200"></a>
                Preparation may occur at any time following creation but must be
                completed prior to initialization.
            </p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-5.4.3"></a>5.4.3. Resolution
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-5.4.3-100"></a>
                Many Java Virtual Machine instructions - <span class="emphasis"><em>anewarray</em></span>, <span
                        class="emphasis"><em>checkcast</em></span>, <span class="emphasis"><em>getfield</em></span>,
                <span class="emphasis"><em>getstatic</em></span>, <span class="emphasis"><em>instanceof</em></span>,
                <span class="emphasis"><em>invokedynamic</em></span>, <span
                        class="emphasis"><em>invokeinterface</em></span>,
                <span class="emphasis"><em>invokespecial</em></span>, <span
                        class="emphasis"><em>invokestatic</em></span>, <span
                        class="emphasis"><em>invokevirtual</em></span>,
                <span class="emphasis"><em>ldc</em></span>, <span class="emphasis"><em>ldc_w</em></span>,
                <span class="emphasis"><em>ldc2_w</em></span>, <span class="emphasis"><em>multianewarray</em></span>,
                <span class="emphasis"><em>new</em></span>, <span class="emphasis"><em>putfield</em></span>, and <span
                        class="emphasis"><em>putstatic</em></span> - rely
                on symbolic references in the run-time constant pool. Execution of any
                of these instructions requires <span class="emphasis"><em>resolution</em></span> of the
                symbolic reference.
            </p>
            <p class="norm"><a id="jvms-5.4.3-200"></a>
                Resolution is the process of dynamically determining one or more
                concrete values from a symbolic reference in the run-time constant
                pool. Initially, all symbolic references in the run-time constant pool
                are unresolved.
            </p>
            <p class="norm"><a id="jvms-5.4.3-300"></a>
                Resolution of an unresolved symbolic reference to (i) a class or
                interface, (ii) a field, (iii) a method, (iv) a method type, (v) a
                method handle, or (vi) a dynamically-computed constant, proceeds in
                accordance with the rules given in <a class="xref"
                                                      href="./jvms-5.html#jvms-5.4.3.1"
                                                      title="5.4.3.1. Class and Interface Resolution">5.4.3.1</a>
                through <a class="xref"
                           href="./jvms-5.html#jvms-5.4.3.5"
                           title="5.4.3.5. Method Type and Method Handle Resolution">5.4.3.5</a>. In the first three of
                those
                sections, the class or interface in whose run-time constant pool the
                symbolic reference appears is labeled <span class="type">D</span>. Then:
            </p>
            <div class="norm">
                <ul class="norm" style="list-style-type: disc; ">
                    <li class="listitem">
                        <p class="norm-error"><a id="jvms-5.4.3-300-A"></a>
                            If no error occurs during resolution of the symbolic reference,
                            then resolution succeeds.
                        </p>
                        <p class="norm-error"><a id="jvms-5.4.3-300-A.1"></a>
                            Subsequent attempts to resolve the symbolic reference always
                            succeed trivially and result in the same entity produced by the
                            initial resolution. If the symbolic reference is to a
                            dynamically-computed constant, the bootstrap method is not
                            re-executed for these subsequent attempts.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm-error"><a id="jvms-5.4.3-300-B"></a>
                            If an error occurs during resolution of the symbolic reference,
                            then it is either (i) an instance of <code
                                    class="literal">IncompatibleClassChangeError</code>
                            (or a subclass);
                            (ii) an instance of <code class="literal">Error</code> (or a subclass) that arose from
                            resolution or invocation of a bootstrap method; or (iii) an
                            instance of <code class="literal">LinkageError</code> (or a subclass) that arose because
                            class
                            loading failed or a loader constraint was violated. The error
                            must be thrown at a point in the program that (directly or
                            indirectly) uses the symbolic reference.
                        </p>
                        <p class="norm-error"><a id="jvms-5.4.3-300-B.1"></a>
                            Subsequent attempts to resolve the symbolic reference always
                            fail with the same error that was thrown as a result of the
                            initial resolution attempt. If the symbolic reference is to a
                            dynamically-computed constant, the bootstrap method is not
                            re-executed for these subsequent attempts.
                        </p>
                    </li>
                </ul>
            </div>
            <p class="note">
                Because errors occurring on an initial attempt at resolution are
                thrown again on subsequent attempts, a class in one module that
                attempts to access, via resolution of a symbolic reference in its
                run-time constant pool, an unexported <code class="literal">public</code> type in a different
                module will always receive the same error indicating an inaccessible
                type (<a class="xref" href="./jvms-5.html#jvms-5.4.4"
                         title="5.4.4. Access Control">5.4.4</a>), <span class="emphasis"><em>even if the Java SE Platform
                     API is used to dynamically export the <code class="literal">public</code> type's package at some
                     time after the class's first attempt</em></span>.
            </p>
            <p class="norm"><a id="jvms-5.4.3-400"></a>
                Resolution of an unresolved symbolic reference to a
                dynamically-computed call site proceeds in accordance with the rules
                given in <a class="xref"
                            href="./jvms-5.html#jvms-5.4.3.6"
                            title="5.4.3.6. Dynamically-Computed Constant and Call Site Resolution">5.4.3.6</a>. Then:
            </p>
            <div class="norm">
                <ul class="norm" style="list-style-type: disc; ">
                    <li class="listitem">
                        <p class="norm"><a id="jvms-5.4.3-400-A"></a>
                            If no error occurs during resolution of the symbolic reference,
                            then resolution succeeds <span class="emphasis"><em>solely for the instruction in
                              the <code class="literal">class</code> file that required resolution</em></span>. This
                            instruction necessarily has an opcode of <span
                                    class="emphasis"><em>invokedynamic</em></span>.
                        </p>
                        <p class="norm"><a id="jvms-5.4.3-400-A.1"></a>
                            Subsequent attempts to resolve the symbolic reference
                            <span class="emphasis"><em>by that instruction in the <code class="literal">class</code>
                              file</em></span>
                            always succeed trivially and result in the same entity produced
                            by the initial resolution. The bootstrap method is not
                            re-executed for these subsequent attempts.
                        </p>
                        <p class="norm"><a id="jvms-5.4.3-400-A.2"></a>
                            The symbolic reference is still unresolved for all other
                            instructions in the <code class="literal">class</code> file, of any opcode, which indicate
                            the same entry in the run-time constant pool as the
                            <span class="emphasis"><em>invokedynamic</em></span> instruction above.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-5.4.3-400-B"></a>
                            If an error occurs during resolution of the symbolic reference,
                            then it is either (i) an instance of <code
                                    class="literal">IncompatibleClassChangeError</code>
                            (or a subclass);
                            (ii) an instance of <code class="literal">Error</code> (or a subclass) that arose from
                            resolution or invocation of a bootstrap method; or (iii) an
                            instance of <code class="literal">LinkageError</code> (or a subclass) that arose because
                            class
                            loading failed or a loader constraint was violated. The error
                            must be thrown at a point in the program that (directly or
                            indirectly) uses the symbolic reference.
                        </p>
                        <p class="norm"><a id="jvms-5.4.3-400-B.1"></a>
                            Subsequent attempts <span class="emphasis"><em>by the same instruction in the
                              <code class="literal">class</code> file</em></span> to resolve the symbolic reference
                            always
                            fail with the same error that was thrown as a result of the
                            initial resolution attempt. The bootstrap method is not
                            re-executed for these subsequent attempts.
                        </p>
                        <p class="norm"><a id="jvms-5.4.3-400-B.2"></a>
                            The symbolic reference is still unresolved for all other
                            instructions in the <code class="literal">class</code> file, of any opcode, which indicate
                            the same entry in the run-time constant pool as the
                            <span class="emphasis"><em>invokedynamic</em></span> instruction above.
                        </p>
                    </li>
                </ul>
            </div>
            <p class="norm"><a id="jvms-5.4.3-500"></a>
                Certain of the instructions above require additional linking checks
                when resolving symbolic references. For instance, in order for a
                <span class="emphasis"><em>getfield</em></span> instruction to successfully resolve the symbolic
                reference
                to the field on which it operates, it must not only complete the field
                resolution steps given in <a class="xref"
                                             href="./jvms-5.html#jvms-5.4.3.2"
                                             title="5.4.3.2. Field Resolution">5.4.3.2</a> but also
                check that the field is not <code class="literal">static</code>. If it is a <code
                        class="literal">static</code> field, a
                linking exception must be thrown.
            </p>
            <p class="norm"><a id="jvms-5.4.3-510"></a>
                Linking exceptions generated by checks that are specific to the
                execution of a particular Java Virtual Machine instruction are given in the
                description of that instruction and are not covered in this general
                discussion of resolution. Note that such exceptions, although
                described as part of the execution of Java Virtual Machine instructions rather than
                resolution, are still properly considered failures of resolution.
            </p>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a id="jvms-5.4.3.1"></a>5.4.3.1. Class and Interface Resolution
                            </h4>
                        </div>
                    </div>
                </div>
                <p class="norm"><a id="jvms-5.4.3.1-100"></a>
                    To resolve an unresolved symbolic reference from <span class="type">D</span> to a class or
                    interface <span class="type">C</span> denoted by <code class="varname">N</code>, the following steps
                    are performed:
                </p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1">
                        <li class="listitem">
                            <p class="norm"><a id="jvms-5.4.3.1-100-A"></a>
                                The defining loader of <span class="type">D</span> is used to load and thereby create a
                                class or interface denoted by <code class="varname">N</code>. This class or interface is
                                <span class="type">C</span>. The details of the process are given in <a class="xref"
                                                                                                        href="./jvms-5.html#jvms-5.3"
                                                                                                        title="5.3. Creation and Loading">5.3</a>.
                            </p>
                            <p class="norm-error"><a id="jvms-5.4.3.1-100-A.1"></a>
                                Any exception that can be thrown as a result of failure to load and thereby create <span
                                        class="type">C</span>
                                can thus be thrown as a result of failure of class and interface
                                resolution.
                            </p>
                        </li>
                        <li class="listitem">
                            <p class="norm"><a id="jvms-5.4.3.1-100-B"></a>
                                If <span class="type">C</span> is an array class and its element type is a <code
                                        class="literal">reference</code> type,
                                then a symbolic reference to the class or interface
                                representing the element type is resolved by invoking the
                                algorithm in <a class="xref"
                                                href="./jvms-5.html#jvms-5.4.3.1"
                                                title="5.4.3.1. Class and Interface Resolution">5.4.3.1</a> recursively.
                            </p>
                        </li>
                        <li class="listitem">
                            <p class="norm"><a id="jvms-5.4.3.1-100-C"></a>
                                Finally, access control is applied for the access from <span class="type">D</span> to
                                <span
                                        class="type">C</span>
                                (<a class="xref"
                                    href="./jvms-5.html#jvms-5.4.4"
                                    title="5.4.4. Access Control">5.4.4</a>).
                            </p>
                        </li>
                    </ol>
                </div>
                <p class="norm"><a id="jvms-5.4.3.1-110"></a>
                    If steps 1 and 2 succeed but step 3 fails, <span class="type">C</span> is still valid and
                    usable. Nevertheless, resolution fails, and <span class="type">D</span> is prohibited from
                    accessing <span class="type">C</span>.
                </p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a id="jvms-5.4.3.2"></a>5.4.3.2. Field Resolution
                            </h4>
                        </div>
                    </div>
                </div>
                <p class="norm-error"><a id="jvms-5.4.3.2-100"></a>
                    To resolve an unresolved symbolic reference from <span class="type">D</span> to a field in a
                    class or interface <span class="type">C</span>, the symbolic reference to <span
                            class="type">C</span>
                    given by the
                    field reference must first be resolved (<a class="xref"
                                                               href="./jvms-5.html#jvms-5.4.3.1"
                                                               title="5.4.3.1. Class and Interface Resolution">5.4.3.1</a>).
                    Therefore, any exception that can be thrown as a result of failure of
                    resolution of a class or interface reference can be thrown as a result
                    of failure of field resolution. If the reference to <span class="type">C</span> can be
                    successfully resolved, an exception relating to the failure of
                    resolution of the field reference itself can be thrown.
                </p>
                <p class="norm"><a id="jvms-5.4.3.2-200"></a>
                    When resolving a field reference, field resolution first attempts to
                    look up the referenced field in <span class="type">C</span> and its superclasses:
                </p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1">
                        <li class="listitem">
                            <p class="norm"><a id="jvms-5.4.3.2-200-A"></a>
                                If <span class="type">C</span> declares a field with the name and descriptor specified
                                by the field reference, field lookup succeeds. The declared
                                field is the result of the field lookup.
                            </p>
                        </li>
                        <li class="listitem">
                            <p class="norm"><a id="jvms-5.4.3.2-200-B"></a>
                                Otherwise, field lookup is applied recursively to the direct
                                superinterfaces of the specified class or interface <span class="type">C</span>.
                            </p>
                        </li>
                        <li class="listitem">
                            <p class="norm"><a id="jvms-5.4.3.2-200-C"></a>
                                Otherwise, if <span class="type">C</span> has a superclass <span class="type">S</span>,
                                field
                                lookup is applied
                                recursively to <span class="type">S</span>.
                            </p>
                        </li>
                        <li class="listitem">
                            <p class="norm"><a id="jvms-5.4.3.2-200-D"></a>
                                Otherwise, field lookup fails.
                            </p>
                        </li>
                    </ol>
                </div>
                <p class="norm"><a id="jvms-5.4.3.2-210"></a>
                    Then, the result of field resolution is determined:
                </p>
                <div class="norm">
                    <ul class="norm" style="list-style-type: disc; ">
                        <li class="listitem">
                            <p class="norm-error"><a id="jvms-5.4.3.2-210-A"></a>
                                If field lookup failed, field resolution throws a <code
                                        class="literal">NoSuchFieldError</code>.
                            </p>
                        </li>
                        <li class="listitem">
                            <p class="norm"><a id="jvms-5.4.3.2-210-B"></a>
                                Otherwise, field lookup succeeded. Access control is applied for
                                the access from <span class="type">D</span> to the field which is the result of field
                                lookup (<a class="xref"
                                           href="./jvms-5.html#jvms-5.4.4"
                                           title="5.4.4. Access Control">5.4.4</a>). Then:
                            </p>
                            <div class="norm">
                                <ul class="norm" style="list-style-type: circle; ">
                                    <li class="listitem">
                                        <p class="norm-error"><a id="jvms-5.4.3.2-210-B-A"></a>
                                            If access control failed, field resolution fails for the same reason.
                                        </p>
                                    </li>
                                    <li class="listitem">
                                        <p class="norm"><a id="jvms-5.4.3.2-210-B-B"></a>
                                            Otherwise, access control succeeded. Loading constraints are
                                            imposed, as follows.
                                        </p>
                                        <p class="norm"><a id="jvms-5.4.3.2-210-B-B.1"></a>
                                            Let <code class="literal">&lt;</code><span class="type">E</span>, <code
                                                    class="varname">L<sub>1</sub></code><code
                                                    class="literal">&gt;</code> be the
                                            class or interface in
                                            which the referenced field is actually declared. Let <code
                                                    class="varname">L<sub>2</sub></code> be
                                            the defining loader of <span class="type">D</span>. Given that the type of
                                            the
                                            referenced field is <span class="type">T<sub>f</sub></span>: if <span
                                                    class="type">T<sub>f</sub></span> is not an array type, let
                                            <span class="type">T</span> be <span class="type">T<sub>f</sub></span>;
                                            otherwise,
                                            let <span class="type">T</span> be the element type of <span
                                                    class="type">T<sub>f</sub></span>.
                                        </p>
                                        <p class="norm-error"><a id="jvms-5.4.3.2-210-B-B.2"></a>
                                            The Java Virtual Machine imposes the loading constraint that
                                            <span class="type">T</span><sup><code
                                                    class="varname">L<sub>1</sub></code></sup> =
                                            <span class="type">T</span><sup><code
                                                    class="varname">L<sub>2</sub></code></sup>.
                                        </p>
                                        <p class="norm-error"><a id="jvms-5.4.3.2-210-B-B.3"></a>
                                            If imposing this constraint results in any loading
                                            constraints being violated (<a class="xref"
                                                                           href="./jvms-5.html#jvms-5.3.4"
                                                                           title="5.3.4. Loading Constraints">5.3.4</a>),
                                            then field resolution fails. Otherwise, field resolution
                                            succeeds.
                                        </p>
                                    </li>
                                </ul>
                            </div>
                        </li>
                    </ul>
                </div>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a id="jvms-5.4.3.3"></a>5.4.3.3. Method Resolution
                            </h4>
                        </div>
                    </div>
                </div>
                <p class="norm-error"><a id="jvms-5.4.3.3-100"></a>
                    To resolve an unresolved symbolic reference from <span class="type">D</span> to a method in a
                    class <span class="type">C</span>, the symbolic reference to <span class="type">C</span> given by
                    the
                    method reference
                    is first resolved (<a class="xref"
                                          href="./jvms-5.html#jvms-5.4.3.1"
                                          title="5.4.3.1. Class and Interface Resolution">5.4.3.1</a>). Therefore, any
                    exception that can be thrown as a result of failure of resolution of a
                    class reference can be thrown as a result of failure of method
                    resolution. If the reference to <span class="type">C</span> can be successfully resolved,
                    exceptions relating to the resolution of the method reference itself
                    can be thrown.
                </p>
                <p class="norm"><a id="jvms-5.4.3.3-200"></a>
                    When resolving a method reference:
                </p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1">
                        <li class="listitem">
                            <p class="norm-error"><a id="jvms-5.4.3.3-200-A"></a>
                                If <span class="type">C</span> is an interface, method resolution throws an <code
                                        class="literal">IncompatibleClassChangeError</code>.
                            </p>
                        </li>
                        <li class="listitem">
                            <p class="norm"><a id="jvms-5.4.3.3-200-B"></a>
                                Otherwise, method resolution attempts to locate the referenced
                                method in <span class="type">C</span> and its superclasses:
                            </p>
                            <div class="norm">
                                <ul class="norm" style="list-style-type: disc; ">
                                    <li class="listitem">
                                        <p class="norm"><a id="jvms-5.4.3.3-200-B-A"></a>
                                            If <span class="type">C</span> declares exactly one method with the name
                                            specified
                                            by the method reference, and the declaration is a signature
                                            polymorphic method (<a class="xref"
                                                                   href="./jvms-2.html#jvms-2.9.3"
                                                                   title="2.9.3. Signature Polymorphic Methods">2.9.3</a>),
                                            then method
                                            lookup succeeds. All the class names mentioned in the
                                            descriptor are resolved (<a class="xref"
                                                                        href="./jvms-5.html#jvms-5.4.3.1"
                                                                        title="5.4.3.1. Class and Interface Resolution">5.4.3.1</a>).
                                        </p>
                                        <p class="norm"><a id="jvms-5.4.3.3-200-B-A.1"></a>
                                            <span class="emphasis"><em>The resolved method is the signature polymorphic
                                          method declaration.</em></span> It is not necessary for <span
                                                    class="type">C</span>
                                            to declare a method with the descriptor specified by the
                                            method reference.
                                        </p>
                                    </li>
                                    <li class="listitem">
                                        <p class="norm"><a id="jvms-5.4.3.3-200-B-B"></a>
                                            Otherwise, if <span class="type">C</span> declares a method with the name
                                            and
                                            descriptor specified by the method reference, method lookup
                                            succeeds.
                                        </p>
                                    </li>
                                    <li class="listitem">
                                        <p class="norm"><a id="jvms-5.4.3.3-200-B-C"></a>
                                            Otherwise, if <span class="type">C</span> has a superclass, step 2 of method
                                            resolution is recursively invoked on the direct superclass
                                            of <span class="type">C</span>.
                                        </p>
                                    </li>
                                </ul>
                            </div>
                        </li>
                        <li class="listitem">
                            <p class="norm"><a id="jvms-5.4.3.3-200-C"></a>
                                Otherwise, method resolution attempts to locate the referenced
                                method in the superinterfaces of the specified class <span class="type">C</span>:
                            </p>
                            <div class="norm">
                                <ul class="norm" style="list-style-type: disc; ">
                                    <li class="listitem">
                                        <p class="norm"><a id="jvms-5.4.3.3-200-C-A"></a>
                                            If the <span class="emphasis"><em>maximally-specific superinterface
                                          methods</em></span> of <span class="type">C</span> for the name and descriptor
                                            specified by the method reference include exactly one method
                                            that does not have its <code class="literal">ACC_ABSTRACT</code> flag set,
                                            then this
                                            method is chosen and method lookup succeeds.
                                        </p>
                                    </li>
                                    <li class="listitem">
                                        <p class="norm"><a id="jvms-5.4.3.3-200-C-B"></a>
                                            Otherwise, if any superinterface of <span class="type">C</span> declares a
                                            method
                                            with the name and descriptor specified by the method
                                            reference that has neither its <code class="literal">ACC_PRIVATE</code> flag
                                            nor its
                                            <code class="literal">ACC_STATIC</code> flag set, one of these is
                                            arbitrarily chosen
                                            and method lookup succeeds.
                                        </p>
                                    </li>
                                    <li class="listitem">
                                        <p class="norm"><a id="jvms-5.4.3.3-200-C-C"></a>
                                            Otherwise, method lookup fails.
                                        </p>
                                    </li>
                                </ul>
                            </div>
                        </li>
                    </ol>
                </div>
                <p class="norm-static"><a id="jvms-5.4.3.3-210"></a>
                    A <span class="emphasis"><em>maximally-specific superinterface method</em></span> of a
                    class or interface <span class="type">C</span> for a particular method name and descriptor is
                    any method for which all of the following are true:
                </p>
                <div class="norm">
                    <ul class="norm" style="list-style-type: disc; ">
                        <li class="listitem">
                            <p class="norm-static"><a id="jvms-5.4.3.3-210-A"></a>
                                The method is declared in a superinterface (direct or indirect)
                                of <span class="type">C</span>.
                            </p>
                        </li>
                        <li class="listitem">
                            <p class="norm-static"><a id="jvms-5.4.3.3-210-B"></a>
                                The method is declared with the specified name and
                                descriptor.
                            </p>
                        </li>
                        <li class="listitem">
                            <p class="norm-static"><a id="jvms-5.4.3.3-210-C"></a>
                                The method has neither its <code class="literal">ACC_PRIVATE</code> flag nor its
                                <code class="literal">ACC_STATIC</code> flag set.
                            </p>
                        </li>
                        <li class="listitem">
                            <p class="norm-static"><a id="jvms-5.4.3.3-210-D"></a>
                                Where the method is declared in interface <span class="type">I</span>, there exists no
                                other maximally-specific superinterface method of <span class="type">C</span> with the
                                specified name and descriptor that is declared in a subinterface
                                of <span class="type">I</span>.
                            </p>
                        </li>
                    </ul>
                </div>
                <p class="norm"><a id="jvms-5.4.3.3-300"></a>
                    The result of method resolution is determined as follows:
                </p>
                <div class="norm">
                    <ul class="norm" style="list-style-type: disc; ">
                        <li class="listitem">
                            <p class="norm-error"><a id="jvms-5.4.3.3-300-A"></a>
                                If method lookup failed, method resolution throws a <code
                                        class="literal">NoSuchMethodError</code>.
                            </p>
                        </li>
                        <li class="listitem">
                            <p class="norm"><a id="jvms-5.4.3.3-300-B"></a>
                                Otherwise, method lookup succeeded. Access control is applied for
                                the access from <span class="type">D</span> to the method which is the result of method
                                lookup (<a class="xref"
                                           href="./jvms-5.html#jvms-5.4.4"
                                           title="5.4.4. Access Control">5.4.4</a>). Then:
                            </p>
                            <div class="norm">
                                <ul class="norm" style="list-style-type: circle; ">
                                    <li class="listitem">
                                        <p class="norm-error"><a id="jvms-5.4.3.3-300-B-A"></a>
                                            If access control failed, method resolution fails for the
                                            same reason.
                                        </p>
                                    </li>
                                    <li class="listitem">
                                        <p class="norm"><a id="jvms-5.4.3.3-300-B-B"></a>
                                            Otherwise, access control succeeded. Loading constraints are
                                            imposed, as follows.
                                        </p>
                                        <p class="norm"><a id="jvms-5.4.3.3-300-B-B.1"></a>
                                            Let <code class="literal">&lt;</code><span class="type">E</span>, <code
                                                    class="varname">L<sub>1</sub></code><code
                                                    class="literal">&gt;</code> be the
                                            class or interface in
                                            which the referenced method <code class="varname">m</code> is actually
                                            declared. Let
                                            <code class="varname">L<sub>2</sub></code> be the defining loader of <span
                                                    class="type">D</span>. Given that the return
                                            type of <code class="varname">m</code> is <span
                                                    class="type">T<sub>r</sub></span>,
                                            and that the formal parameter types of
                                            <code class="varname">m</code> are <span class="type">T<sub>f1</sub></span>,
                                            ...,
                                            <span class="type">T<sub>fn</sub></span>:
                                        </p>
                                        <p class="norm"><a id="jvms-5.4.3.3-300-B-B.2"></a>
                                            If <span class="type">T<sub>r</sub></span> is not an array type, let <span
                                                    class="type">T<sub>0</sub></span> be <span
                                                    class="type">T<sub>r</sub></span>;
                                            otherwise,
                                            let <span class="type">T<sub>0</sub></span> be the element type of <span
                                                    class="type">T<sub>r</sub></span>.
                                        </p>
                                        <p class="norm"><a id="jvms-5.4.3.3-300-B-B.3"></a>
                                            For <span class="emphasis"><em>i</em></span> = 1 to <span
                                                    class="emphasis"><em>n</em></span>: If <span
                                                    class="type">T<sub>fi</sub></span>
                                            is not an array type, let
                                            <span class="type">T<sub>i</sub></span> be <span class="type">T<sub>fi</sub></span>;
                                            otherwise, let <span class="type">T<sub>i</sub></span> be the element type
                                            of
                                            <span class="type">T<sub>fi</sub></span>.
                                        </p>
                                        <p class="norm-error"><a id="jvms-5.4.3.3-300-B-B.4"></a>
                                            The Java Virtual Machine imposes the loading constraints
                                            <span class="type">T<sub>i</sub></span><sup><code
                                                    class="varname">L<sub>1</sub></code></sup> =
                                            <span class="type">T<sub>i</sub></span><sup><code
                                                    class="varname">L<sub>2</sub></code></sup> for <span
                                                    class="emphasis"><em>i</em></span> = 0 to <span
                                                    class="emphasis"><em>n</em></span>.
                                        </p>
                                        <p class="norm-error"><a id="jvms-5.4.3.3-300-B-B.5"></a>
                                            If imposing these constraints results in any loading
                                            constraints being violated (<a class="xref"
                                                                           href="./jvms-5.html#jvms-5.3.4"
                                                                           title="5.3.4. Loading Constraints">5.3.4</a>),
                                            then method resolution fails. Otherwise, method resolution
                                            succeeds.
                                        </p>
                                    </li>
                                </ul>
                            </div>
                        </li>
                    </ul>
                </div>
                <p class="note">
                    When resolution searches for a method in the class's superinterfaces,
                    the best outcome is to identify a maximally-specific non-<code class="literal">abstract</code>
                    method. It is possible that this method will be chosen by method
                    selection, so it is desirable to add class loader constraints for
                    it.
                </p>
                <p class="note">
                    Otherwise, the result is nondeterministic. This is not new: <em class="citetitle">The <span
                        class="trademark">Java</span> Virtual Machine Specification</em>
                    has never identified exactly which method is chosen, and how "ties"
                    should be broken. Prior to Java SE 8, this was mostly an unobservable
                    distinction. However, beginning with Java SE 8, the set of interface
                    methods is more heterogenous, so care must be taken to avoid problems
                    with nondeterministic behavior. Thus:
                </p>
                <div class="note">
                    <ul class="note" style="list-style-type: disc; ">
                        <li class="listitem">
                            <p class="note">Superinterface methods that are <code class="literal">private</code> and
                                <code class="literal">static</code> are ignored by resolution. This is consistent with
                                the
                                Java programming language, where such interface methods are not
                                inherited.
                            </p>
                        </li>
                        <li class="listitem">
                            <p class="note">Any behavior controlled by the resolved method
                                should not depend on whether the method is <code class="literal">abstract</code> or
                                not.
                            </p>
                        </li>
                    </ul>
                </div>
                <p class="note">Note that if the result of resolution is an
                    <code class="literal">abstract</code> method, the referenced class <span class="type">C</span> may
                    be
                    non-<code class="literal">abstract</code>. Requiring <span class="type">C</span> to be <code
                            class="literal">abstract</code> would conflict with the
                    nondeterministic choice of superinterface methods. Instead, resolution
                    assumes that the run time class of the invoked object has a concrete
                    implementation of the method.
                </p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a id="jvms-5.4.3.4"></a>5.4.3.4. Interface Method Resolution
                            </h4>
                        </div>
                    </div>
                </div>
                <p class="norm-error"><a id="jvms-5.4.3.4-100"></a>
                    To resolve an unresolved symbolic reference from <span class="type">D</span> to an interface
                    method in an interface <span class="type">C</span>, the symbolic reference to <span
                            class="type">C</span> given by the
                    interface method reference is first resolved
                    (<a class="xref" href="./jvms-5.html#jvms-5.4.3.1"
                        title="5.4.3.1. Class and Interface Resolution">5.4.3.1</a>). Therefore, any exception that can
                    be
                    thrown as a result of failure of resolution of an interface reference
                    can be thrown as a result of failure of interface method
                    resolution. If the reference to <span class="type">C</span> can be successfully resolved,
                    exceptions relating to the resolution of the interface method
                    reference itself can be thrown.
                </p>
                <p class="norm"><a id="jvms-5.4.3.4-200"></a>
                    When resolving an interface method reference:
                </p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1">
                        <li class="listitem">
                            <p class="norm-error"><a id="jvms-5.4.3.4-200-A"></a>
                                If <span class="type">C</span> is not an interface, interface method resolution throws
                                an <code class="literal">IncompatibleClassChangeError</code>.
                            </p>
                        </li>
                        <li class="listitem">
                            <p class="norm-dynamic"><a id="jvms-5.4.3.4-200-B"></a>
                                Otherwise, if <span class="type">C</span> declares a method with the name and descriptor
                                specified by the interface method reference, method lookup
                                succeeds.
                            </p>
                        </li>
                        <li class="listitem">
                            <p class="norm-dynamic"><a id="jvms-5.4.3.4-200-C"></a>
                                Otherwise, if the class <code class="literal">Object</code> declares a method with the
                                name
                                and descriptor specified by the interface method reference,
                                which has its <code class="literal">ACC_PUBLIC</code> flag set and does not have its
                                <code class="literal">ACC_STATIC</code> flag set, method lookup succeeds.
                            </p>
                        </li>
                        <li class="listitem">
                            <p class="norm-dynamic"><a id="jvms-5.4.3.4-200-D"></a>
                                Otherwise, if the maximally-specific superinterface methods
                                (<a class="xref"
                                    href="./jvms-5.html#jvms-5.4.3.3"
                                    title="5.4.3.3. Method Resolution">5.4.3.3</a>) of <span class="type">C</span> for
                                the
                                name and
                                descriptor specified by the method reference include exactly one
                                method that does not have its <code class="literal">ACC_ABSTRACT</code> flag set, then
                                this
                                method is chosen and method lookup succeeds.
                            </p>
                        </li>
                        <li class="listitem">
                            <p class="norm-dynamic"><a id="jvms-5.4.3.4-200-E"></a>
                                Otherwise, if any superinterface of <span class="type">C</span> declares a method with
                                the name and descriptor specified by the method reference that
                                has neither its <code class="literal">ACC_PRIVATE</code> flag nor its <code
                                        class="literal">ACC_STATIC</code> flag
                                set, one of these is arbitrarily chosen and method lookup
                                succeeds.
                            </p>
                        </li>
                        <li class="listitem">
                            <p class="norm-dynamic"><a id="jvms-5.4.3.4-200-F"></a>
                                Otherwise, method lookup fails.
                            </p>
                        </li>
                    </ol>
                </div>
                <p class="norm"><a id="jvms-5.4.3.4-300"></a>
                    The result of interface method resolution is determined as follows:
                </p>
                <div class="norm">
                    <ul class="norm" style="list-style-type: disc; ">
                        <li class="listitem">
                            <p class="norm-error"><a id="jvms-5.4.3.4-300-A"></a>
                                If method lookup failed, interface method resolution throws a <code
                                        class="literal">NoSuchMethodError</code>.
                            </p>
                        </li>
                        <li class="listitem">
                            <p class="norm-error"><a id="jvms-5.4.3.4-300-B"></a>

                                Otherwise, method lookup succeeded. Access control is applied for
                                the access from <span class="type">D</span> to the method which is the result of method
                                lookup (<a class="xref"
                                           href="./jvms-5.html#jvms-5.4.4"
                                           title="5.4.4. Access Control">5.4.4</a>). Then:
                            </p>
                            <div class="norm">
                                <ul class="norm" style="list-style-type: circle; ">
                                    <li class="listitem">
                                        <p class="norm-error"><a id="jvms-5.4.3.4-300-B-A"></a>
                                            If access control failed, interface method resolution fails
                                            for the same reason.
                                        </p>
                                    </li>
                                    <li class="listitem">
                                        <p class="norm"><a id="jvms-5.4.3.4-300-B-B"></a>
                                            Otherwise, access control succeeded. Loading constraints are
                                            imposed, as follows.
                                        </p>
                                        <p class="norm"><a id="jvms-5.4.3.4-300-B-B.1"></a>
                                            Let <code class="literal">&lt;</code><span class="type">E</span>, <code
                                                    class="varname">L<sub>1</sub></code><code
                                                    class="literal">&gt;</code> be the
                                            class or interface in
                                            which the referenced interface method <code class="varname">m</code> is
                                            actually
                                            declared. Let <code class="varname">L<sub>2</sub></code> be the defining
                                            loader of
                                            <span class="type">D</span>. Given that
                                            the return type of <code class="varname">m</code> is <span
                                                    class="type">T<sub>r</sub></span>, and that the formal
                                            parameter types of <code class="varname">m</code> are <span
                                                    class="type">T<sub>f1</sub></span>, ..., <span
                                                    class="type">T<sub>fn</sub></span>:
                                        </p>
                                        <p class="norm"><a id="jvms-5.4.3.4-300-B-B.2"></a>
                                            If <span class="type">T<sub>r</sub></span> is not an array type, let <span
                                                    class="type">T<sub>0</sub></span> be <span
                                                    class="type">T<sub>r</sub></span>;
                                            otherwise,
                                            let <span class="type">T<sub>0</sub></span> be the element type of <span
                                                    class="type">T<sub>r</sub></span>.
                                        </p>
                                        <p class="norm"><a id="jvms-5.4.3.4-300-B-B.3"></a>
                                            For <span class="emphasis"><em>i</em></span> = 1 to <span
                                                    class="emphasis"><em>n</em></span>: If <span
                                                    class="type">T<sub>fi</sub></span>
                                            is not an array type, let
                                            <span class="type">T<sub>i</sub></span> be <span class="type">T<sub>fi</sub></span>;
                                            otherwise, let <span class="type">T<sub>i</sub></span> be the element type
                                            of
                                            <span class="type">T<sub>fi</sub></span>.
                                        </p>
                                        <p class="norm-error"><a id="jvms-5.4.3.4-300-B-B.4"></a>
                                            The Java Virtual Machine imposes the loading constraints
                                            <span class="type">T<sub>i</sub></span><sup><code
                                                    class="varname">L<sub>1</sub></code></sup> =
                                            <span class="type">T<sub>i</sub></span><sup><code
                                                    class="varname">L<sub>2</sub></code></sup> for <span
                                                    class="emphasis"><em>i</em></span> = 0 to
                                            <span class="emphasis"><em>n</em></span>.
                                        </p>
                                        <p class="norm-error"><a id="jvms-5.4.3.4-300-B-B.5"></a>
                                            If imposing these constraints results in any loading
                                            constraints being violated (<a class="xref"
                                                                           href="./jvms-5.html#jvms-5.3.4"
                                                                           title="5.3.4. Loading Constraints">5.3.4</a>),
                                            then interface method resolution fails. Otherwise, interface
                                            method resolution succeeds.
                                        </p>
                                    </li>
                                </ul>
                            </div>
                        </li>
                    </ul>
                </div>
                <p class="note">
                    Access control is necessary because interface method resolution may
                    pick a <code class="literal">private</code> method of interface <span class="type">C</span>. (Prior
                    to
                    Java SE 8, the
                    result of interface method resolution could be a non-<code class="literal">public</code> method
                    of class <code class="literal">Object</code> or a <code class="literal">static</code> method of
                    class
                    <code class="literal">Object</code>; such results
                    were not consistent with the inheritance model of the Java programming language, and
                    are disallowed in Java SE 8 and above.)
                </p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a id="jvms-5.4.3.5"></a>5.4.3.5. Method Type and Method Handle
                                Resolution
                            </h4>
                        </div>
                    </div>
                </div>
                <p class="norm-dynamic"><a id="jvms-5.4.3.5-100"></a>
                    To resolve an unresolved symbolic reference to a method type,

                    it is as if resolution occurs of unresolved symbolic references to
                    classes and interfaces (<a class="xref"
                                               href="./jvms-5.html#jvms-5.4.3.1"
                                               title="5.4.3.1. Class and Interface Resolution">5.4.3.1</a>) whose names
                    correspond to the types given in the method descriptor
                    (<a class="xref" href="./jvms-4.html#jvms-4.3.3"
                        title="4.3.3. Method Descriptors">4.3.3</a>).
                </p>
                <p class="norm-error"><a id="jvms-5.4.3.5-110"></a>
                    Any exception that can be thrown as a result of failure of resolution
                    of a class reference can thus be thrown as a result of failure of
                    method type resolution.
                </p>
                <p class="norm-dynamic"><a id="jvms-5.4.3.5-120"></a>
                    The result of successful method type resolution is a <code class="literal">reference</code> to an
                    instance of <code class="literal">java.lang.invoke.MethodType</code> which represents the method
                    descriptor.
                </p>
                <p class="note">
                    Method type resolution occurs regardless of whether the run-time
                    constant pool actually contains symbolic references to classes and
                    interfaces indicated in the method descriptor. Also, the resolution is
                    deemed to occur on <span class="emphasis"><em>unresolved</em></span> symbolic
                    references, so a failure to resolve one method type will not
                    necessarily lead to a later failure to resolve another method type
                    with the same textual method descriptor, if suitable classes and
                    interfaces can be loaded by the later time.
                </p>
                <p class="norm"><a id="jvms-5.4.3.5-200"></a>
                    Resolution of an unresolved symbolic reference to a method handle is
                    more complicated. Each method handle resolved by the Java Virtual Machine has an
                    equivalent instruction sequence called its <span class="emphasis"><em>bytecode
                        behavior</em></span>, indicated by the method
                    handle's <span class="emphasis"><em>kind</em></span>. The integer values and
                    descriptions of the nine kinds of method handle are given in
                    <a class="xref"
                       href="./jvms-5.html#jvms-5.4.3.5-220"
                       title="Table 5.4.3.5-A. Bytecode Behaviors for Method Handles">Table 5.4.3.5-A</a>.
                </p>
                <p class="norm"><a id="jvms-5.4.3.5-210"></a>
                    Symbolic references by an instruction sequence to fields or methods
                    are indicated by <code class="literal">C.x:T</code>, where <code class="literal">x</code>
                    and <code class="literal">T</code> are the name and descriptor
                    (<a class="xref" href="./jvms-4.html#jvms-4.3.2"
                        title="4.3.2. Field Descriptors">4.3.2</a>, <a class="xref"
                                                                       href="./jvms-4.html#jvms-4.3.3"
                                                                       title="4.3.3. Method Descriptors">4.3.3</a>) of
                    the
                    field or method, and <code class="literal">C</code> is the class or interface in
                    which the field or method is to be found.
                </p>
                <div class="table"><a id="jvms-5.4.3.5-220"></a>
                    <p class="title"><b>Table 5.4.3.5-A. Bytecode Behaviors for Method Handles</b></p>
                    <div class="table-contents">
                        <table class="table" summary="Bytecode Behaviors for Method Handles" border="1">
                            <colgroup>
                                <col/>
                                <col/>
                                <col/>
                            </colgroup>
                            <thead>
                            <tr>
                                <th>Kind</th>
                                <th>Description</th>
                                <th>Interpretation</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>1</td>
                                <td><code class="literal">REF_getField</code></td>
                                <td><code class="literal">getfield C.f:T</code></td>
                            </tr>
                            <tr>
                                <td>2</td>
                                <td><code class="literal">REF_getStatic</code></td>
                                <td><code class="literal">getstatic C.f:T</code></td>
                            </tr>
                            <tr>
                                <td>3</td>
                                <td><code class="literal">REF_putField</code></td>
                                <td><code class="literal">putfield C.f:T</code></td>
                            </tr>
                            <tr>
                                <td>4</td>
                                <td><code class="literal">REF_putStatic</code></td>
                                <td><code class="literal">putstatic C.f:T</code></td>
                            </tr>
                            <tr>
                                <td>5</td>
                                <td><code class="literal">REF_invokeVirtual</code></td>
                                <td><code class="literal">invokevirtual C.m:(A*)T</code></td>
                            </tr>
                            <tr>
                                <td>6</td>
                                <td><code class="literal">REF_invokeStatic</code></td>
                                <td><code class="literal">invokestatic C.m:(A*)T</code></td>
                            </tr>
                            <tr>
                                <td>7</td>
                                <td><code class="literal">REF_invokeSpecial</code></td>
                                <td><code class="literal">invokespecial C.m:(A*)T</code></td>
                            </tr>
                            <tr>
                                <td>8</td>
                                <td><code class="literal">REF_newInvokeSpecial</code></td>
                                <td><code class="literal">new C; dup; invokespecial
                                    C.<code class="literal">&lt;init&gt;</code>:(A*)V</code></td>
                            </tr>
                            <tr>
                                <td>9</td>
                                <td><code class="literal">REF_invokeInterface</code></td>
                                <td><code class="literal">invokeinterface C.m:(A*)T</code></td>
                            </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
                <br class="table-break"/>
                <p class="norm"><a id="jvms-5.4.3.5-230"></a>
                    Let <code class="varname">MH</code> be the symbolic reference to a method handle
                    (<a class="xref" href="./jvms-5.html#jvms-5.1"
                        title="5.1. The Run-Time Constant Pool">5.1</a>) being resolved. Also:
                </p>
                <div class="norm">
                    <ul class="norm" style="list-style-type: disc; ">
                        <li class="listitem">
                            <p class="norm"><a id="jvms-5.4.3.5-230-A"></a>
                                Let <span class="type">R</span> be the symbolic reference to the field or method
                                contained within <code class="varname">MH</code>.
                            </p>
                            <p class="norm"><a id="jvms-5.4.3.5-230-A.1"></a>
                                <span class="type">R</span> is derived from the <code
                                        class="literal">CONSTANT_Fieldref</code>,
                                <code class="literal">CONSTANT_Methodref</code>, or <code
                                        class="literal">CONSTANT_InterfaceMethodref</code> structure
                                referred to by the <code class="literal">reference_index</code> item of
                                the <code class="literal">CONSTANT_MethodHandle</code> from which <code
                                        class="varname">MH</code> is derived.
                            </p>
                            <p class="note">For example, <span class="type">R</span> is a symbolic reference to <span
                                    class="type">C</span>
                                <code class="literal">.</code> <code class="varname">f</code> for bytecode behavior of
                                kind
                                1, and a symbolic
                                reference to <span class="type">C</span> <code class="literal">.</code> <code
                                        class="literal">&lt;init&gt;</code> for bytecode behavior of kind
                                8.
                            </p>
                            <p class="norm"><a id="jvms-5.4.3.5-230-A.2"></a>
                                If <code class="varname">MH</code>'s bytecode behavior is kind 7 (<code
                                        class="literal">REF_invokeSpecial</code>),
                                then <span class="type">C</span> must be the current class or interface, a superclass of
                                the current class, a direct superinterface of the current class
                                or interface, or <code class="literal">Object</code>.
                            </p>
                        </li>
                        <li class="listitem">
                            <p class="norm"><a id="jvms-5.4.3.5-230-B"></a>
                                Let <span class="type">T</span> be the type of the field referenced by <span
                                        class="type">R</span>, or the
                                return type of the method referenced by <span class="type">R</span>. Let <span
                                        class="type">A</span>* be the
                                sequence (perhaps empty) of parameter types of the method
                                referenced by <span class="type">R</span>.
                            </p>
                            <p class="norm"><a id="jvms-5.4.3.5-230-B.1"></a>
                                <span class="type">T</span> and <span class="type">A</span>* are derived from the <code
                                        class="literal">CONSTANT_NameAndType</code>
                                structure referred to by the
                                <code class="literal">name_and_type_index</code> item in the
                                <code class="literal">CONSTANT_Fieldref</code>, <code
                                        class="literal">CONSTANT_Methodref</code>, or
                                <code class="literal">CONSTANT_InterfaceMethodref</code> structure from which <span
                                        class="type">R</span> is
                                derived.
                            </p>
                        </li>
                    </ul>
                </div>
                <p class="norm-error"><a id="jvms-5.4.3.5-240"></a>
                    To resolve <code class="varname">MH</code>, all symbolic references to classes, interfaces,
                    fields, and methods in <code class="varname">MH</code>'s bytecode behavior are resolved, using
                    the following four steps:
                </p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1">
                        <li class="listitem">
                            <p class="norm"><a id="jvms-5.4.3.5-240-A"></a>
                                <span class="type">R</span> is resolved. This occurs as if by field resolution
                                (<a class="xref"
                                    href="./jvms-5.html#jvms-5.4.3.2"
                                    title="5.4.3.2. Field Resolution">5.4.3.2</a>) when <code class="varname">MH</code>'s
                                bytecode behavior
                                is kind 1, 2, 3, or 4, and as if by method resolution
                                (<a class="xref"
                                    href="./jvms-5.html#jvms-5.4.3.3"
                                    title="5.4.3.3. Method Resolution">5.4.3.3</a>) when <code class="varname">MH</code>'s
                                bytecode behavior
                                is kind 5, 6, 7, or 8, and as if by interface method resolution
                                (<a class="xref"
                                    href="./jvms-5.html#jvms-5.4.3.4"
                                    title="5.4.3.4. Interface Method Resolution">5.4.3.4</a>) when <code
                                        class="varname">MH</code>'s bytecode behavior
                                is kind 9.
                            </p>
                        </li>
                        <li class="listitem">
                            <p class="norm"><a id="jvms-5.4.3.5-240-B"></a>
                                The following constraints apply to the result of
                                resolving <span class="type">R</span>. These constraints correspond to those that would
                                be enforced during verification or execution of the instruction
                                sequence for the relevant bytecode behavior.
                            </p>
                            <div class="norm">
                                <ul class="norm" style="list-style-type: disc; ">
                                    <li class="listitem">
                                        <p class="norm"><a id="jvms-5.4.3.5-240-B-A"></a>
                                            If <code class="varname">MH</code>'s bytecode behavior is kind 8 (<code
                                                    class="literal">REF_newInvokeSpecial</code>),
                                            then <span class="type">R</span> must resolve to an instance initialization
                                            method
                                            declared in class <span class="type">C</span>.
                                        </p>
                                    </li>
                                    <li class="listitem">
                                        <p class="norm"><a id="jvms-5.4.3.5-240-B-B"></a>
                                            If <span class="type">R</span> resolves to a <code
                                                    class="literal">protected</code>
                                            member, then the following
                                            rules apply depending on the kind of <code class="varname">MH</code>'s
                                            bytecode
                                            behavior:

                                        </p>
                                        <div class="norm">
                                            <ul class="norm" style="list-style-type: circle; ">
                                                <li class="listitem">
                                                    <p class="norm"><a id="jvms-5.4.3.5-240-B-B-A"></a>
                                                        For kinds 1, 3, and 5 (<code class="literal">REF_getField</code>,
                                                        <code
                                                                class="literal">REF_putField</code>, and
                                                        <code class="literal">REF_invokeVirtual</code>): If <code
                                                                class="literal">C.f</code>
                                                        or <code class="literal">C.m</code> resolved to a <code
                                                                class="literal">protected</code> field or
                                                        method, and <span class="type">C</span> is in a different
                                                        run-time package
                                                        than the
                                                        current class, then <span class="type">C</span> must be
                                                        assignable to the
                                                        current
                                                        class.

                                                    </p>
                                                </li>
                                                <li class="listitem">
                                                    <p class="norm"><a id="jvms-5.4.3.5-240-B-B-B"></a>
                                                        For kind 8 (<code class="literal">REF_newInvokeSpecial</code>):
                                                        If <span
                                                                class="type">C</span> <code class="literal">.</code>
                                                        <code
                                                                class="literal">&lt;init&gt;</code> resolved
                                                        to a <code class="literal">protected</code> method, then <span
                                                                class="type">C</span> must be declared in the
                                                        same run-time package as the current class.
                                                    </p>
                                                </li>
                                            </ul>
                                        </div>
                                    </li>
                                    <li class="listitem">
                                        <p class="norm"><a id="jvms-5.4.3.5-240-B-C"></a>
                                            <span class="type">R</span> must resolve to a <code
                                                    class="literal">static</code> or
                                            non-<code class="literal">static</code> member depending
                                            on the kind of <code class="varname">MH</code>'s bytecode behavior:
                                        </p>
                                        <div class="norm">
                                            <ul class="norm" style="list-style-type: circle; ">
                                                <li class="listitem">
                                                    <p class="norm"><a id="jvms-5.4.3.5-240-B-C-A"></a>
                                                        For kinds 1, 3, 5, 7, and 9 (<code
                                                                class="literal">REF_getField</code>,
                                                        <code class="literal">REF_putField</code>,
                                                        <code class="literal">REF_invokeVirtual</code>, <code
                                                                class="literal">REF_invokeSpecial</code>, and
                                                        <code class="literal">REF_invokeInterface</code>): <code
                                                                class="literal">C.f</code>
                                                        or <code class="literal">C.m</code> must resolve to a non-<code
                                                                class="literal">static</code>
                                                        field or method.
                                                    </p>
                                                </li>
                                                <li class="listitem">
                                                    <p class="norm"><a id="jvms-5.4.3.5-240-B-C-B"></a>
                                                        For kinds 2, 4, and 6 (<code
                                                                class="literal">REF_getStatic</code>, <code
                                                                class="literal">REF_putStatic</code>, and
                                                        <code class="literal">REF_invokeStatic</code>): <code
                                                                class="literal">C.f</code>
                                                        or <code class="literal">C.m</code> must resolve to a <code
                                                                class="literal">static</code> field
                                                        or method.
                                                    </p>
                                                </li>
                                            </ul>
                                        </div>
                                    </li>
                                </ul>
                            </div>
                        </li>
                        <li class="listitem">
                            <p class="norm"><a id="jvms-5.4.3.5-240-C"></a>
                                Resolution occurs as if of unresolved symbolic references to
                                classes and interfaces whose names correspond to each type in
                                <span class="type">A</span>*, and to the type <span class="type">T</span>, in that
                                order.
                            </p>
                        </li>
                        <li class="listitem">
                            <p class="norm"><a id="jvms-5.4.3.5-240-D"></a>
                                A reference to an instance of <code class="literal">java.lang.invoke.MethodType</code>
                                is
                                obtained as if by
                                resolution of an unresolved symbolic reference to a method type
                                that contains the method descriptor specified in
                                <a class="xref"
                                   href="./jvms-5.html#jvms-5.4.3.5-250"
                                   title="Table 5.4.3.5-B. Method Descriptors for Method Handles">Table 5.4.3.5-B</a>
                                for the kind of <code class="varname">MH</code>.
                            </p>
                            <p class="note">It is as if the symbolic reference to a method
                                handle contains a symbolic reference to the method type that the
                                resolved method handle will eventually have. The detailed
                                structure of the method type is obtained by inspecting
                                <a class="xref"
                                   href="./jvms-5.html#jvms-5.4.3.5-250"
                                   title="Table 5.4.3.5-B. Method Descriptors for Method Handles">Table 5.4.3.5-B</a>.
                            </p>
                            <div class="table"><a id="jvms-5.4.3.5-250"></a>
                                <p class="title"><b>Table 5.4.3.5-B. Method Descriptors for Method Handles</b></p>
                                <div class="table-contents">
                                    <table class="table" summary="Method Descriptors for Method Handles" border="1">
                                        <colgroup>
                                            <col/>
                                            <col/>
                                            <col/>
                                        </colgroup>
                                        <thead>
                                        <tr>
                                            <th>Kind</th>
                                            <th>Description</th>
                                            <th>Method descriptor</th>
                                        </tr>
                                        </thead>
                                        <tbody>
                                        <tr>
                                            <td>1</td>
                                            <td><code class="literal">REF_getField</code></td>
                                            <td><code class="literal">(C)T</code></td>
                                        </tr>
                                        <tr>
                                            <td>2</td>
                                            <td><code class="literal">REF_getStatic</code></td>
                                            <td><code class="literal">()T</code></td>
                                        </tr>
                                        <tr>
                                            <td>3</td>
                                            <td><code class="literal">REF_putField</code></td>
                                            <td><code class="literal">(C,T)V</code></td>
                                        </tr>
                                        <tr>
                                            <td>4</td>
                                            <td><code class="literal">REF_putStatic</code></td>
                                            <td><code class="literal">(T)V</code></td>
                                        </tr>
                                        <tr>
                                            <td>5</td>
                                            <td><code class="literal">REF_invokeVirtual</code></td>
                                            <td><code class="literal">(C,A*)T</code></td>
                                        </tr>
                                        <tr>
                                            <td>6</td>
                                            <td><code class="literal">REF_invokeStatic</code></td>
                                            <td><code class="literal">(A*)T</code></td>
                                        </tr>
                                        <tr>
                                            <td>7</td>
                                            <td><code class="literal">REF_invokeSpecial</code></td>
                                            <td><code class="literal">(C,A*)T</code></td>
                                        </tr>
                                        <tr>
                                            <td>8</td>
                                            <td><code class="literal">REF_newInvokeSpecial</code></td>
                                            <td><code class="literal">(A*)C</code></td>
                                        </tr>
                                        <tr>
                                            <td>9</td>
                                            <td><code class="literal">REF_invokeInterface</code></td>
                                            <td><code class="literal">(C,A*)T</code></td>
                                        </tr>
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                            <br class="table-break"/>
                        </li>
                    </ol>
                </div>
                <p class="norm"><a id="jvms-5.4.3.5-260"></a>

                    In steps 1, 3, and 4, any exception that can be thrown as a result of
                    failure of resolution of a symbolic reference to a class, interface,
                    field, or method can be thrown as a result of failure of method handle
                    resolution. In step 2, any failure due to the specified constraints
                    causes a failure of method handle resolution due to an <code
                            class="literal">IllegalAccessError</code>.
                </p>
                <p class="note">The intent is that resolving a method handle can be
                    done in exactly the same circumstances that the Java Virtual Machine would
                    successfully verify and resolve the symbolic references in the
                    bytecode behavior. In particular, method handles to <code class="literal">private</code>,
                    <code class="literal">protected</code>, and <code class="literal">static</code> members can be
                    created
                    in exactly those
                    classes for which the corresponding normal accesses are legal.
                </p>
                <p class="norm-dynamic"><a id="jvms-5.4.3.5-300"></a>
                    The result of successful method handle resolution is a <code class="literal">reference</code> to an
                    instance of <code class="literal">java.lang.invoke.MethodHandle</code> which represents the method
                    handle
                    <code class="varname">MH</code>.
                </p>
                <p class="norm-dynamic"><a id="jvms-5.4.3.5-310"></a>
                    The type descriptor of this <code class="literal">java.lang.invoke.MethodHandle</code> instance is
                    the
                    <code class="literal">java.lang.invoke.MethodType</code> instance produced in the third step of
                    method
                    handle
                    resolution above.
                </p>
                <p class="note">The type descriptor of a method handle is such that
                    a valid call to <code class="literal">invokeExact</code> in <code
                            class="literal">java.lang.invoke.MethodHandle</code> on the method handle
                    has exactly the same stack effects as the bytecode behavior. Calling
                    this method handle on a valid set of arguments has exactly the same
                    effect and returns the same result (if any) as the corresponding
                    bytecode behavior.
                </p>
                <p class="norm-dynamic"><a id="jvms-5.4.3.5-320"></a>
                    If the method referenced by <span class="type">R</span> has the <code
                            class="literal">ACC_VARARGS</code> flag
                    set (<a class="xref" href="./jvms-4.html#jvms-4.6"
                            title="4.6. Methods">4.6</a>), then the <code
                            class="literal">java.lang.invoke.MethodHandle</code>
                    instance is
                    a variable arity method handle; otherwise, it is a fixed arity method
                    handle.
                </p>
                <p class="norm-dynamic"><a id="jvms-5.4.3.5-330"></a>
                    A variable arity method handle performs argument list boxing (JLS
                    15.12.4.2) when invoked via <code class="literal">invoke</code>, while its behavior with respect
                    to <code class="literal">invokeExact</code> is as if the <code class="literal">ACC_VARARGS</code>
                    flag
                    were not set.
                </p>
                <p class="norm-error"><a id="jvms-5.4.3.5-340"></a>
                    Method handle resolution throws an <code class="literal">IncompatibleClassChangeError</code> if the
                    method
                    referenced by <span class="type">R</span> has the <code class="literal">ACC_VARARGS</code> flag set
                    and either <span class="type">A</span>* is an empty sequence or the
                    last parameter type in <span class="type">A</span>* is not
                    an array type. That is, creation of a variable arity method handle
                    fails.
                </p>
                <p class="norm"><a id="jvms-5.4.3.5-400"></a>
                    An implementation of the Java Virtual Machine is not required to intern method types
                    or method handles. That is, two distinct symbolic references to method
                    types or method handles which are structurally identical might not
                    resolve to the same instance of <code class="literal">java.lang.invoke.MethodType</code> or <code
                            class="literal">java.lang.invoke.MethodHandle</code>
                    respectively.
                </p>
                <p class="note">The <code class="literal">java.lang.invoke.MethodHandles</code>
                    class in the Java SE Platform API allows creation of method handles with no
                    bytecode behavior. Their behavior is defined by the method of
                    <code class="literal">java.lang.invoke.MethodHandles</code> that creates
                    them. For example, a method handle may, when invoked, first apply
                    transformations to its argument values, then supply the transformed
                    values to the invocation of another method handle, then apply a
                    transformation to the value returned from that invocation, then return
                    the transformed value as its own result.
                </p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a id="jvms-5.4.3.6"></a>5.4.3.6. Dynamically-Computed Constant and
                                Call Site Resolution
                            </h4>
                        </div>
                    </div>
                </div>
                <p class="norm"><a id="jvms-5.4.3.6-100"></a>
                    To resolve an unresolved symbolic reference <span class="type">R</span> to a
                    dynamically-computed constant or call site, there are three
                    tasks. First, <span class="type">R</span> is examined to determine which code will serve as
                    its <span class="emphasis"><em>bootstrap method</em></span>, and which arguments will be
                    passed to that code. Second, the arguments are packaged into an array
                    and the bootstrap method is invoked. Third, the result of the
                    bootstrap method is validated, and used as the result of
                    resolution.
                </p>
                <p class="norm"><a id="jvms-5.4.3.6-200"></a>
                    The first task involves the following steps:
                </p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1">
                        <li class="listitem">
                            <p class="norm"><a id="jvms-5.4.3.6-200-A"></a>
                                <span class="type">R</span> gives a symbolic reference to a <span
                                        class="emphasis"><em>bootstrap method
                                 handle</em></span>. The bootstrap method handle is resolved
                                (<a class="xref"
                                    href="./jvms-5.html#jvms-5.4.3.5"
                                    title="5.4.3.5. Method Type and Method Handle Resolution">5.4.3.5</a>) to obtain a
                                <code
                                        class="literal">reference</code> to an
                                instance of <code class="literal">java.lang.invoke.MethodHandle</code>.
                            </p>
                            <p class="norm"><a id="jvms-5.4.3.6-200-A.1"></a>
                                Any exception that can be thrown as a result of failure of
                                resolution of a symbolic reference to a method handle can be
                                thrown in this step.
                            </p>
                            <p class="norm"><a id="jvms-5.4.3.6-200-A.2"></a>
                                If <span class="type">R</span> is a symbolic reference to a dynamically-computed
                                constant, then let <span class="type">D</span> be the type descriptor of the bootstrap
                                method handle. (That is, <span class="type">D</span> is a <code
                                        class="literal">reference</code> to an instance of
                                <code class="literal">java.lang.invoke.MethodType</code>.) The first parameter type
                                indicated
                                by <span class="type">D</span> must be
                                <code class="literal">java.lang.invoke.MethodHandles.Lookup</code>, or else resolution
                                fails
                                with a
                                <code class="literal">BootstrapMethodError</code>. For historical reasons, the bootstrap
                                method handle for a
                                dynamically-computed call site is not similarly constrained.
                            </p>
                        </li>
                        <li class="listitem">
                            <p class="norm"><a id="jvms-5.4.3.6-200-B"></a>
                                If <span class="type">R</span> is a symbolic reference to a dynamically-computed
                                constant, then it gives a field descriptor.
                            </p>
                            <p class="norm"><a id="jvms-5.4.3.6-200-B.1"></a>
                                If the field descriptor indicates a primitive type, then a <code
                                        class="literal">reference</code>
                                to the pre-defined <code class="literal">Class</code> object representing that type is
                                obtained (see the method <code class="literal">isPrimitive</code> in class <code
                                        class="literal">Class</code>).
                            </p>
                            <p class="norm"><a id="jvms-5.4.3.6-200-B.2"></a>
                                Otherwise, the field descriptor indicates a class or interface
                                type, or an array type. A <code class="literal">reference</code> to the <code
                                        class="literal">Class</code> object
                                representing the type indicated by the field descriptor is obtained,
                                as if by resolution of an unresolved symbolic reference to a
                                class or interface (<a class="xref"
                                                       href="./jvms-5.html#jvms-5.4.3.1"
                                                       title="5.4.3.1. Class and Interface Resolution">5.4.3.1</a>)
                                whose name
                                corresponds to the type indicated by the field descriptor.
                            </p>
                            <p class="norm"><a id="jvms-5.4.3.6-200-B.3"></a>
                                Any exception that can be thrown as a result of failure of
                                resolution of a symbolic reference to a class or interface can
                                be thrown in this step.
                            </p>
                        </li>
                        <li class="listitem">
                            <p class="norm"><a id="jvms-5.4.3.6-200-C"></a>
                                If <span class="type">R</span> is a symbolic reference to a dynamically-computed call
                                site, then it gives a method descriptor.
                            </p>
                            <p class="norm"><a id="jvms-5.4.3.6-200-C.1"></a>
                                A <code class="literal">reference</code> to an instance of <code
                                        class="literal">java.lang.invoke.MethodType</code> is obtained, as if by
                                resolution of an unresolved symbolic reference to a method type
                                (<a class="xref"
                                    href="./jvms-5.html#jvms-5.4.3.5"
                                    title="5.4.3.5. Method Type and Method Handle Resolution">5.4.3.5</a>) with the same
                                parameter and
                                return types as the method descriptor.
                            </p>
                            <p class="norm"><a id="jvms-5.4.3.6-200-C.2"></a>
                                Any exception that can be thrown as a result of failure of
                                resolution of a symbolic reference to a method type can be thrown
                                in this step.
                            </p>
                        </li>
                        <li class="listitem">
                            <p class="norm"><a id="jvms-5.4.3.6-200-D"></a>
                                <span class="type">R</span> gives zero or more <span class="emphasis"><em>static
                                 arguments</em></span>,
                                which communicate application-specific metadata to the bootstrap
                                method. Each static argument <span class="type">A</span> is resolved, in the order given
                                by <span class="type">R</span>, as follows:
                            </p>
                            <div class="norm">
                                <ul class="norm" style="list-style-type: disc; ">
                                    <li class="listitem">
                                        <p class="norm"><a id="jvms-5.4.3.6-200-D-A"></a>
                                            If <span class="type">A</span> is a string constant, then a <code
                                                    class="literal">reference</code> to its instance of
                                            class <code class="literal">String</code> is obtained.
                                        </p>
                                    </li>
                                    <li class="listitem">
                                        <p class="norm"><a id="jvms-5.4.3.6-200-D-B"></a>
                                            If <span class="type">A</span> is a numeric constant, then a <code
                                                    class="literal">reference</code> to an instance of
                                            <code class="literal">java.lang.invoke.MethodHandle</code> is obtained by
                                            the
                                            following procedure:
                                        </p>
                                        <div class="orderedlist">
                                            <ol class="orderedlist" type="a">
                                                <li class="listitem">
                                                    <p class="norm"><a id="jvms-5.4.3.6-200-D-B-A"></a>
                                                        Let <code class="varname">v</code> be the value of the numeric
                                                        constant,
                                                        and let <span class="type">T</span> be
                                                        a field descriptor which corresponds to the type of the
                                                        numeric constant.
                                                    </p>
                                                </li>
                                                <li class="listitem">
                                                    <p class="norm"><a id="jvms-5.4.3.6-200-D-B-B"></a>
                                                        Let <code class="varname">MH</code> be a method handle produced
                                                        as if by
                                                        invocation
                                                        of the <code class="literal">identity</code> method of <code
                                                                class="literal">java.lang.invoke.MethodHandles</code>
                                                        with an
                                                        argument representing the class <code
                                                                class="literal">Object</code>.
                                                    </p>
                                                </li>
                                                <li class="listitem">
                                                    <p class="norm"><a id="jvms-5.4.3.6-200-D-B-C"></a>
                                                        A <code class="literal">reference</code> to an instance of <code
                                                                class="literal">java.lang.invoke.MethodHandle</code> is
                                                        obtained as
                                                        if by the invocation <code class="literal">MH.invoke(v)</code>
                                                        with method descriptor
                                                        <code class="literal">(T)Ljava/lang/Object;</code>.
                                                    </p>
                                                </li>
                                            </ol>
                                        </div>
                                    </li>
                                    <li class="listitem">
                                        <p class="norm"><a id="jvms-5.4.3.6-200-D-C"></a>
                                            If <span class="type">A</span> is a symbolic reference to a
                                            dynamically-computed
                                            constant with a field descriptor indicating a primitive type
                                            <span class="type">T</span>, then <span class="type">A</span> is resolved,
                                            producing
                                            a primitive value
                                            <code class="varname">v</code>. Given <code class="varname">v</code> and
                                            <span
                                                    class="type">T</span>, a <code class="literal">reference</code> is
                                            obtained to an
                                            instance
                                            of <code class="literal">java.lang.invoke.MethodHandle</code> according to
                                            the
                                            procedure specified above
                                            for numeric constants.
                                        </p>
                                    </li>
                                    <li class="listitem">
                                        <p class="norm"><a id="jvms-5.4.3.6-200-D-D"></a>
                                            If <span class="type">A</span> is any other kind of symbolic reference, then
                                            the
                                            result is the result of resolving <span class="type">A</span>.
                                        </p>
                                    </li>
                                </ul>
                            </div>
                            <p class="norm"><a id="jvms-5.4.3.6-200-D.1"></a>
                                Among the symbolic references in the run-time constant pool,
                                symbolic references to dynamically-computed constants are
                                special because they are derived from <code class="literal">constant_pool</code> entries
                                that can syntactically refer to themselves via the
                                <code class="literal">BootstrapMethods</code> attribute (<a class="xref"
                                                                                            href="./jvms-4.html#jvms-4.7.23"
                                                                                            title="4.7.23. The BootstrapMethods Attribute">4.7.23</a>).
                                However, the Java Virtual Machine does not support resolving a symbolic
                                reference to a dynamically-computed constant that depends on
                                itself (that is, as a static argument to its own bootstrap
                                method). Accordingly, when both <span class="type">R</span> and <span
                                        class="type">A</span>
                                are symbolic
                                references to dynamically-computed constants, if <span class="type">A</span> is the same
                                as <span class="type">R</span> or <span class="type">A</span> gives a static argument
                                that
                                (directly or
                                indirectly) references <span class="type">R</span>, then resolution fails with a <code
                                        class="literal">StackOverflowError</code>
                                at the point where re-resolution of <span class="type">R</span> would be
                                required.
                            </p>
                            <p class="note">Unlike class initialization
                                (<a class="xref"
                                    href="./jvms-5.html#jvms-5.5"
                                    title="5.5. Initialization">5.5</a>), where cycles are allowed between
                                uninitialized classes, resolution does not allow cycles in
                                symbolic references to dynamically-computed constants. If an
                                implementation of resolution makes recursive use of a stack,
                                then a <code class="literal">StackOverflowError</code> will occur naturally. If not, the
                                implementation is
                                required to detect the cycle rather than, say, looping
                                infinitely or returning a default value for the
                                dynamically-computed constant.
                            </p>
                            <p class="note">A similar cycle may arise if the body of a
                                bootstrap method makes reference to a dynamically-computed
                                constant currently being resolved. This has always been possible
                                for <span class="emphasis"><em>invokedynamic</em></span> bootstraps, and does not
                                require
                                special
                                treatment in resolution; the recursive <code class="literal">invokeWithArguments</code>
                                calls will naturally lead to a <code class="literal">StackOverflowError</code>.
                            </p>
                            <p class="norm"><a id="jvms-5.4.3.6-200-D.2"></a>
                                Any exception that can be thrown as a result of failure of
                                resolution of a symbolic reference can be thrown in this step.
                            </p>
                        </li>
                    </ol>
                </div>
                <p class="norm"><a id="jvms-5.4.3.6-300"></a>
                    The second task, to invoke the bootstrap method handle, involves the
                    following steps:
                </p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1">
                        <li class="listitem">
                            <p class="norm"><a id="jvms-5.4.3.6-300-A"></a>
                                An array is allocated with component type <code class="literal">Object</code> and length
                                <span class="emphasis"><em>n</em></span>+3, where <span
                                        class="emphasis"><em>n</em></span> is
                                the number of static arguments given
                                by <span class="type">R</span> (<span class="emphasis"><em>n</em></span> <span
                                        class="symbol">&#8805;</span> 0).
                            </p>
                            <p class="norm"><a id="jvms-5.4.3.6-300-A.1"></a>
                                The zeroth component of the array is set to a <code class="literal">reference</code> to
                                an
                                instance of <code class="literal">java.lang.invoke.MethodHandles.Lookup</code> for the
                                class
                                in which <span class="type">R</span>
                                occurs, produced as if by invocation of the <code class="literal">lookup</code> method
                                of
                                <code class="literal">java.lang.invoke.MethodHandles</code>.
                            </p>
                            <p class="norm"><a id="jvms-5.4.3.6-300-A.2"></a>
                                The first component of the array is set to a <code class="literal">reference</code> to
                                an
                                instance of <code class="literal">String</code> that denotes <code
                                        class="varname">N</code>,
                                the unqualified name
                                given by <span class="type">R</span>.
                            </p>
                            <p class="norm"><a id="jvms-5.4.3.6-300-A.3"></a>
                                The second component of the array is set to the <code class="literal">reference</code>
                                to an
                                instance of <code class="literal">Class</code> or <code
                                        class="literal">java.lang.invoke.MethodType</code> that was obtained earlier
                                for the field descriptor or method descriptor given by <span class="type">R</span>.
                            </p>
                            <p class="norm"><a id="jvms-5.4.3.6-300-A.4"></a>
                                Subsequent components of the array are set to the <code class="literal">reference</code>s
                                that
                                were obtained earlier from resolving <span class="type">R</span>'s static arguments, if
                                any. The <code class="literal">reference</code>s appear in the array in the same order
                                as the
                                corresponding static arguments are given by <span class="type">R</span>.
                            </p>
                            <p class="note">A Java Virtual Machine implementation may be able to skip
                                allocation of the array and, without any change in observable
                                behavior, pass the arguments directly to the bootstrap method.
                            </p>
                        </li>
                        <li class="listitem">
                            <p class="norm"><a id="jvms-5.4.3.6-300-B"></a>
                                The bootstrap method handle is invoked, as if by the invocation
                                <code class="literal">BMH.invokeWithArguments(args)</code>,
                                where <code class="literal">BMH</code> is the bootstrap method handle and
                                <code class="literal">args</code> is the array allocated above.
                            </p>
                            <p class="note">Due to the behavior of the <code class="literal">invokeWithArguments</code>
                                method of <code class="literal">java.lang.invoke.MethodHandle</code>, the type
                                descriptor of
                                the bootstrap
                                method handle need not exactly match the run-time types of the
                                arguments. For example, the second parameter type of the
                                bootstrap method handle (corresponding to the unqualified name
                                given in the first component of the array above) could be
                                <code class="literal">Object</code> instead of <code class="literal">String</code>. If
                                the
                                bootstrap method handle is
                                variable arity, then some or all of the arguments may be
                                collected into a trailing array parameter.
                            </p>
                            <p class="norm"><a id="jvms-5.4.3.6-300-B.1"></a>
                                The invocation occurs within a thread that is attempting
                                resolution of this symbolic reference. If there are several such
                                threads, the bootstrap method handle may be invoked
                                concurrently. Bootstrap methods which access global application
                                data should take the usual precautions against race conditions.
                            </p>
                            <p class="norm"><a id="jvms-5.4.3.6-300-B.2"></a>
                                If the invocation fails by throwing an instance of <code class="literal">Error</code> or
                                a
                                subclass of <code class="literal">Error</code>, resolution fails with that exception.
                            </p>
                            <p class="norm"><a id="jvms-5.4.3.6-300-B.3"></a>
                                If the invocation fails by throwing an exception that is not an
                                instance of <code class="literal">Error</code> or a subclass of <code
                                        class="literal">Error</code>, resolution fails
                                with a <code class="literal">BootstrapMethodError</code> whose cause is the thrown
                                exception.
                            </p>
                            <p class="norm"><a id="jvms-5.4.3.6-300-B.4"></a>
                                If several threads concurrently invoke the bootstrap method
                                handle for this symbolic reference, the Java Virtual Machine chooses the result
                                of one invocation and installs it visibly to all threads. Any
                                other bootstrap methods executing for this symbolic reference
                                are allowed to complete, but their results are ignored.
                            </p>
                        </li>
                    </ol>
                </div>
                <p class="norm"><a id="jvms-5.4.3.6-400"></a>
                    The third task, to validate the <code class="literal">reference</code>, <code
                            class="varname">o</code>, produced by invocation of
                    the bootstrap method handle, is as follows:
                </p>
                <div class="norm">
                    <ul class="norm" style="list-style-type: disc; ">
                        <li class="listitem">
                            <p class="norm"><a id="jvms-5.4.3.6-400-A"></a>
                                If <span class="type">R</span> is a symbolic reference to a dynamically-computed
                                constant, then <code class="varname">o</code> is converted to type <span
                                        class="type">T</span>, the type indicated
                                by the field descriptor given by <span class="type">R</span>.
                            </p>
                            <p class="norm"><a id="jvms-5.4.3.6-400-A.1"></a>
                                <code class="varname">o</code>'s conversion occurs as if by the
                                invocation <code class="literal">MH.invoke(o)</code> with method
                                descriptor <code class="literal">(Ljava/lang/Object;)T</code>, where <code
                                        class="varname">MH</code>
                                is a method handle produced as if by invocation of the
                                <code class="literal">identity</code> method of <code
                                        class="literal">java.lang.invoke.MethodHandles</code> with an argument
                                representing the class <code class="literal">Object</code>.
                            </p>
                            <p class="norm"><a id="jvms-5.4.3.6-400-A.2"></a>
                                The result of <code class="varname">o</code>'s conversion is the result of resolution.
                            </p>
                            <p class="norm"><a id="jvms-5.4.3.6-400-A.3"></a>
                                If the conversion fails by throwing a <code class="literal">NullPointerException</code>
                                or a
                                <code class="literal">ClassCastException</code>,
                                resolution fails with a <code class="literal">BootstrapMethodError</code>.
                            </p>
                        </li>
                        <li class="listitem">
                            <p class="norm"><a id="jvms-5.4.3.6-400-B"></a>
                                If <span class="type">R</span> is a symbolic reference to a dynamically-computed call
                                site, then <code class="varname">o</code> is the result of resolution if it has all of
                                the
                                following properties:
                            </p>
                            <div class="norm">
                                <ul class="norm" style="list-style-type: circle; ">
                                    <li class="listitem">
                                        <p class="norm"><a id="jvms-5.4.3.6-400-B-A"></a>
                                            <code class="varname">o</code> is not <code class="literal">null</code>.
                                        </p>
                                    </li>
                                    <li class="listitem">
                                        <p class="norm"><a id="jvms-5.4.3.6-400-B-B"></a>
                                            <code class="varname">o</code> is an instance of <code
                                                    class="literal">java.lang.invoke.CallSite</code> or a subclass of
                                            <code
                                                    class="literal">java.lang.invoke.CallSite</code>.
                                        </p>
                                    </li>
                                    <li class="listitem">
                                        <p class="norm"><a id="jvms-5.4.3.6-400-B-C"></a>
                                            The type of the <code class="literal">java.lang.invoke.CallSite</code> is
                                            semantically equal to the
                                            method descriptor given by <span class="type">R</span>.
                                        </p>
                                    </li>
                                </ul>
                            </div>
                            <p class="norm"><a id="jvms-5.4.3.6-400-B.1"></a>
                                If <code class="varname">o</code> does not have these properties, resolution fails with
                                a
                                <code class="literal">BootstrapMethodError</code>.
                            </p>
                        </li>
                    </ul>
                </div>
                <p class="norm"><a id="jvms-5.4.3.6-500"></a>
                    Many of the steps above perform computations "as if by invocation" of
                    certain methods. In each case, the invocation behavior is given in
                    detail by the specifications for <span class="emphasis"><em>invokestatic</em></span> and
                    <span class="emphasis"><em>invokevirtual</em></span>. The invocation occurs in the thread and from
                    the
                    class that is attempting resolution of the symbolic reference
                    <span class="type">R</span>. However, no corresponding method references are required to
                    appear in the run-time constant pool, no particular method's operand
                    stack is necessarily used, and the value of
                    the <code class="literal">max_stack</code> item of any method's <code class="literal">Code</code>
                    attribute
                    is not enforced for the invocation.
                </p>
                <p class="norm"><a id="jvms-5.4.3.6-510"></a>
                    If several threads attempt resolution of <span class="type">R</span> at the same time, the
                    bootstrap method may be invoked concurrently. Therefore, bootstrap
                    methods which access global application data must take precautions
                    against race conditions.
                </p>
            </div>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-5.4.4"></a>5.4.4. Access Control
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-5.4.4-100"></a>
                Access control is applied during resolution (<a class="xref"
                                                                href="./jvms-5.html#jvms-5.4.3"
                                                                title="5.4.3. Resolution">5.4.3</a>)
                to ensure that a reference to a class, interface, field, or method is
                permitted. Access control succeeds if a specified class, interface,
                field, or method is <span class="emphasis"><em>accessible</em></span> to the
                referring class or interface.
            </p>
            <p class="norm"><a id="jvms-5.4.4-200"></a>
                A class or interface <span class="type">C</span> is accessible to a class or interface <span
                        class="type">D</span> if
                and only if one of the following is true:
            </p>
            <div class="norm">
                <ul class="norm" style="list-style-type: disc; ">
                    <li class="listitem">
                        <p class="norm"><a id="jvms-5.4.4-200-A"></a>
                            <span class="type">C</span> is <code class="literal">public</code>,
                            and a member of the same run-time module as <span class="type">D</span>
                            (<a class="xref"
                                href="./jvms-5.html#jvms-5.3.6"
                                title="5.3.6. Modules and Layers">5.3.6</a>).
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-5.4.4-200-B"></a>
                            <span class="type">C</span> is <code class="literal">public</code>,
                            and a member of a different run-time module than <span class="type">D</span>,
                            and <span class="type">C</span>'s run-time module is read by <span class="type">D</span>'s
                            run-time module,
                            and <span class="type">C</span>'s run-time module exports <span class="type">C</span>'s
                            run-time
                            package
                            to <span class="type">D</span>'s run-time module.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-5.4.4-200-C"></a>
                            <span class="type">C</span> is not <code class="literal">public</code>,
                            and <span class="type">C</span> and <span class="type">D</span> are members of the same
                            run-time
                            package.
                        </p>
                    </li>
                </ul>
            </div>
            <p class="norm-error"><a id="jvms-5.4.4-210"></a>
                If <span class="type">C</span> is not accessible to <span class="type">D</span>, then access control
                throws an <code class="literal">IllegalAccessError</code>.
                Otherwise, access control succeeds.
            </p>
            <p class="norm"><a id="jvms-5.4.4-300"></a>
                A field or method <span class="type">R</span> is accessible to a class or interface <span
                        class="type">D</span> if and
                only if any of the following is true:
            </p>
            <div class="norm">
                <ul class="norm" style="list-style-type: disc; ">
                    <li class="listitem">
                        <p class="norm"><a id="jvms-5.4.4-300-A"></a>
                            <span class="type">R</span> is <code class="literal">public</code>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-5.4.4-300-B"></a>
                            <span class="type">R</span> is <code class="literal">protected</code> and is declared in a
                            class
                            <span class="type">C</span>, and <span class="type">D</span> is
                            either a subclass of <span class="type">C</span> or <span class="type">C</span> itself.
                        </p>
                        <p class="norm"><a id="jvms-5.4.4-300-B.1"></a>
                            Furthermore, if <span class="type">R</span> is not <code class="literal">static</code>, then
                            the
                            symbolic reference
                            to <span class="type">R</span> must contain a symbolic reference to a class <span
                                    class="type">T</span>, such
                            that <span class="type">T</span> is either a subclass of <span class="type">D</span>, a
                            superclass of <span class="type">D</span>, or
                            <span class="type">D</span> itself.
                        </p>
                        <p class="note">
                            During verification of <span class="type">D</span>, it was required that, even if <span
                                class="type">T</span> is
                            a superclass of <span class="type">D</span>, the target reference of a <code
                                class="literal">protected</code> field
                            access or method invocation must be an instance of <span class="type">D</span> or a
                            subclass of <span class="type">D</span> (<a class="xref"
                                                                        href="./jvms-4.html#jvms-4.10.1.8"
                                                                        title="4.10.1.8. Type Checking for protected Members">4.10.1.8</a>).
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-5.4.4-300-C"></a>
                            <span class="type">R</span> is either <code class="literal">protected</code> or has default
                            access (that is,
                            neither <code class="literal">public</code> nor <code class="literal">protected</code> nor
                            <code
                                    class="literal">private</code>), and is declared
                            by a class in the same run-time package as <span class="type">D</span>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-5.4.4-300-D"></a>
                            <span class="type">R</span> is <code class="literal">private</code> and is declared by a
                            class
                            or
                            interface <span class="type">C</span> that belongs to the same nest as <span
                                    class="type">D</span>, according to the
                            nestmate test below.
                        </p>
                    </li>
                </ul>
            </div>
            <p class="norm-error"><a id="jvms-5.4.4-310"></a>
                If <span class="type">R</span> is not accessible to <span class="type">D</span>, then access control
                throws an <code class="literal">IllegalAccessError</code>.
                Otherwise, access control succeeds.
            </p>
            <p class="norm"><a id="jvms-5.4.4-400"></a>
                A <span class="emphasis"><em>nest</em></span> is a set of classes and interfaces that
                allow mutual access to their <code class="literal">private</code> members. One of the classes or
                interfaces is the <span class="emphasis"><em>nest host</em></span>. It enumerates the
                classes and interfaces which belong to the nest, using the
                <code class="literal">NestMembers</code> attribute (<a class="xref"
                                                                       href="./jvms-4.html#jvms-4.7.29"
                                                                       title="4.7.29. The NestMembers Attribute">4.7.29</a>).
                Each of them
                in turn designates it as the nest host, using the <code class="literal">NestHost</code> attribute
                (<a class="xref" href="./jvms-4.html#jvms-4.7.28"
                    title="4.7.28. The NestHost Attribute">4.7.28</a>). A class or interface which lacks a
                <code class="literal">NestHost</code> attribute belongs to the nest hosted by itself; if it also
                lacks a <code class="literal">NestMembers</code> attribute, then this nest is a singleton
                consisting only of the class or interface itself.
            </p>
            <p class="norm"><a id="jvms-5.4.4-410"></a>
                The Java Virtual Machine determines the nest to which a given class or interface belongs
                (that is, the nest host designated by the class or interface)
                as part of access control, rather than when the class or interface is
                loaded. Certain methods of the Java SE Platform API may determine the nest
                to which a given class or interface belongs prior to access control,
                in which case the Java Virtual Machine respects that prior determination during
                access control.
            </p>
            <p class="norm"><a id="jvms-5.4.4-500"></a>
                To determine whether a class or interface <span class="type">C</span> belongs to the same nest
                as a class or interface <span class="type">D</span>, the <span class="emphasis"><em>nestmate
                     test</em></span> is
                applied. <span class="type">C</span> and <span class="type">D</span> belong to the same nest if and only
                if the
                nestmate test succeeds. The nestmate test is as follows:
            </p>
            <div class="norm">
                <ul class="norm" style="list-style-type: disc; ">
                    <li class="listitem">
                        <p class="norm"><a id="jvms-5.4.4-500-A"></a>
                            If <span class="type">C</span> and <span class="type">D</span> are the same class or
                            interface,
                            then the nestmate test succeeds.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-5.4.4-500-B"></a>
                            Otherwise, the following steps are performed, in order:
                        </p>
                        <div class="orderedlist">
                            <ol class="orderedlist" type="1">
                                <li class="listitem">
                                    <p class="norm"><a id="jvms-5.4.4-500-B-A"></a>

                                        Let <span class="type">H</span> be the nest host of <span class="type">D</span>,
                                        if the
                                        nest host of <span class="type">D</span> has
                                        previously been determined. If the nest host of <span class="type">D</span> has
                                        <span class="emphasis"><em>not</em></span> previously been determined, then it
                                        is
                                        determined using the algorithm below, yielding <span class="type">H</span>.
                                    </p>
                                </li>
                                <li class="listitem">
                                    <p class="norm"><a id="jvms-5.4.4-500-B-B"></a>

                                        Let <span class="type">H'</span> be the nest host of <span class="type">C</span>,
                                        if
                                        the nest host of <span class="type">C</span>
                                        has previously been determined. If the nest host of <span class="type">C</span>
                                        has
                                        <span class="emphasis"><em>not</em></span> previously been determined, then it
                                        is
                                        determined using the algorithm below, yielding <span class="type">H'</span>.
                                    </p>
                                </li>
                                <li class="listitem">
                                    <p class="norm"><a id="jvms-5.4.4-500-B-C"></a>
                                        <span class="type">H</span> and <span class="type">H'</span> are compared. If
                                        <span
                                                class="type">H</span> and <span class="type">H'</span> are the same
                                        class or interface, then the nestmate test succeeds.
                                        Otherwise, the nestmate test fails.

                                    </p>
                                </li>
                            </ol>
                        </div>
                    </li>
                </ul>
            </div>
            <p class="norm"><a id="jvms-5.4.4-510"></a>
                The nest host of a class or interface <code class="varname">M</code> is determined as follows:
            </p>
            <div class="norm">
                <ul class="norm" style="list-style-type: disc; ">
                    <li class="listitem">
                        <p class="norm"><a id="jvms-5.4.4-510-A"></a>
                            If <code class="varname">M</code> lacks a <code class="literal">NestHost</code> attribute,
                            then <code class="varname">M</code> is its own nest host.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-5.4.4-510-B"></a>
                            Otherwise, <code class="varname">M</code> has a <code class="literal">NestHost</code>
                            attribute,
                            and its
                            <code class="literal">host_class_index</code> item is used as an index
                            into the run-time constant pool of <code class="varname">M</code>. The symbolic reference
                            at that index is resolved (<a class="xref"
                                                          href="./jvms-5.html#jvms-5.4.3.1"
                                                          title="5.4.3.1. Class and Interface Resolution">5.4.3.1</a>).
                        </p>
                        <p class="norm"><a id="jvms-5.4.4-510-B.1"></a>

                            If resolution of the symbolic reference fails, then <code class="varname">M</code>
                            is its own nest host. Any exception thrown as a result of
                            failure of class or interface resolution is <span class="emphasis"><em>not</em></span>
                            rethrown.
                        </p>
                        <p class="norm"><a id="jvms-5.4.4-510-B.2"></a>

                            Otherwise, resolution of the symbolic reference succeeds.
                            Let <span class="type">H</span> be the resolved class or interface. The nest host of
                            <code class="varname">M</code> is determined by the following rules:
                        </p>
                        <div class="norm">
                            <ul class="norm" style="list-style-type: circle; ">
                                <li class="listitem">
                                    <p class="norm"><a id="jvms-5.4.4-510-B.2-A"></a>
                                        If any of the following is true,
                                        then <code class="varname">M</code> is its own nest host:
                                    </p>
                                    <div class="norm">
                                        <ul class="norm" style="list-style-type: square; ">
                                            <li class="listitem">
                                                <p class="norm"><a id="jvms-5.4.4-510-B.2-A-A"></a>
                                                    <span class="type">H</span> is not in the same run-time package as
                                                    <code
                                                            class="varname">M</code>.
                                                </p>
                                            </li>
                                            <li class="listitem">
                                                <p class="norm"><a id="jvms-5.4.4-510-B.2-A-B"></a>
                                                    <span class="type">H</span> lacks a <code class="literal">NestMembers</code>
                                                    attribute.
                                                </p>
                                            </li>
                                            <li class="listitem">
                                                <p class="norm"><a id="jvms-5.4.4-510-B.2-A-C"></a>
                                                    <span class="type">H</span> has a <code
                                                            class="literal">NestMembers</code>
                                                    attribute, but there is no
                                                    entry in its <code class="literal">classes</code> array
                                                    that refers to a class or interface with the
                                                    name <code class="varname">N</code>, where <code
                                                            class="varname">N</code> is
                                                    the name of <code class="varname">M</code>.
                                                </p>
                                            </li>
                                        </ul>
                                    </div>
                                </li>
                                <li class="listitem">
                                    <p class="norm"><a id="jvms-5.4.4-510-B.2-B"></a>
                                        Otherwise, <span class="type">H</span> is the nest host of <code
                                                class="varname">M</code>.
                                    </p>
                                </li>
                            </ul>
                        </div>
                    </li>
                </ul>
            </div>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-5.4.5"></a>5.4.5. Method Overriding
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-5.4.5-100"></a>
                An instance method <code class="varname">m<sub>C</sub></code> <span class="emphasis"><em>can
                     override</em></span> another
                instance method <code class="varname">m<sub>A</sub></code> iff all of the following are true:
            </p>
            <div class="norm">
                <ul class="norm" style="list-style-type: disc; ">
                    <li class="listitem">
                        <p class="norm"><a id="jvms-5.4.5-100-A"></a>
                            <code class="varname">m<sub>C</sub></code> has the same name and descriptor as <code
                                    class="varname">m<sub>A</sub></code>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm-static"><a id="jvms-5.4.5-100-B"></a>
                            <code class="varname">m<sub>C</sub></code> is not marked <code
                                    class="literal">ACC_PRIVATE</code>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-5.4.5-100-C"></a>
                            One of the following is true:
                        </p>
                        <div class="norm">
                            <ul class="norm" style="list-style-type: circle; ">
                                <li class="listitem">
                                    <p class="norm"><a id="jvms-5.4.5-100-C-A"></a>
                                        <code class="varname">m<sub>A</sub></code> is marked <code
                                                class="literal">ACC_PUBLIC</code>.
                                    </p>
                                </li>
                                <li class="listitem">
                                    <p class="norm"><a id="jvms-5.4.5-100-C-B"></a>
                                        <code class="varname">m<sub>A</sub></code> is marked <code
                                                class="literal">ACC_PROTECTED</code>.
                                    </p>
                                </li>
                                <li class="listitem">
                                    <p class="norm"><a id="jvms-5.4.5-100-C-C"></a>
                                        <code class="varname">m<sub>A</sub></code> is marked neither <code
                                                class="literal">ACC_PUBLIC</code> nor <code class="literal">ACC_PROTECTED</code>
                                        nor
                                        <code class="literal">ACC_PRIVATE</code>, and either (a) the declaration of
                                        <code
                                                class="varname">m<sub>A</sub></code>
                                        appears in the same run-time package as the declaration of
                                        <code class="varname">m<sub>C</sub></code>, or (b) if <code
                                                class="varname">m<sub>A</sub></code> is declared in a class <span
                                                class="type">A</span> and <code class="varname">m<sub>C</sub></code> is
                                        declared in a class <span class="type">C</span>, then there exists a method
                                        <code
                                                class="varname">m<sub>B</sub></code>
                                        declared in a class <span class="type">B</span> such that <span
                                                class="type">C</span>
                                        is a subclass of <span class="type">B</span>
                                        and <span class="type">B</span> is a subclass of <span class="type">A</span> and
                                        <code
                                                class="varname">m<sub>C</sub></code> can override <code
                                                class="varname">m<sub>B</sub></code> and
                                        <code class="varname">m<sub>B</sub></code> can override <code
                                                class="varname">m<sub>A</sub></code>.
                                    </p>
                                </li>
                            </ul>
                        </div>
                    </li>
                </ul>
            </div>
            <div class="informalexample">
                <p class="note">Part (b) of the final case allows for "transitive
                    overriding" of methods with default access. For example, given the
                    following class declarations in a package <span class="type">P</span>:
                </p>
                <pre class="programlisting">public class A           {        void m() {} }
public class B extends A { public void m() {} }
public class C extends B {        void m() {} }
</pre>
                <p class="note">and the following class declaration in a different
                    package:
                </p>
                <pre class="programlisting">public class D extends P.C { void m() {} }
</pre>
                <p class="note">then:</p>
                <div class="note">
                    <ul class="note" style="list-style-type: disc; ">
                        <li class="listitem">
                            <p class="note">
                                <code class="literal">B.m</code> can override <code class="literal">A.m</code>.
                            </p>
                        </li>
                        <li class="listitem">
                            <p class="note">
                                <code class="literal">C.m</code> can override <code class="literal">B.m</code>
                                and <code class="literal">A.m</code>.
                            </p>
                        </li>
                        <li class="listitem">
                            <p class="note">
                                <code class="literal">D.m</code> can override <code class="literal">B.m</code> and,
                                transitively, <code class="literal">A.m</code>, but it cannot
                                override <code class="literal">C.m</code>.
                            </p>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-5.4.6"></a>5.4.6. Method Selection
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-5.4.6-100"></a>
                During execution of an <span class="emphasis"><em>invokeinterface</em></span> or <span
                        class="emphasis"><em>invokevirtual</em></span>
                instruction, a method is <span class="emphasis"><em>selected</em></span> with respect to
                (i) the run-time type of the object on the stack, and (ii) a method
                that was previously <span class="emphasis"><em>resolved</em></span> by the instruction.
                The rules to select a method with respect to a class or interface <span class="type">C</span>
                and a method <code class="varname">m<sub>R</sub></code> are as follows:
            </p>
            <div class="orderedlist">
                <ol class="orderedlist" type="1">
                    <li class="listitem">
                        <p class="norm"><a id="jvms-5.4.6-100-A"></a>
                            If <code class="varname">m<sub>R</sub></code> is marked <code
                                    class="literal">ACC_PRIVATE</code>, then it is the selected method.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-5.4.6-100-B"></a>
                            Otherwise, the selected method is determined by the following
                            lookup procedure:
                        </p>
                        <div class="norm">
                            <ul class="norm" style="list-style-type: disc; ">
                                <li class="listitem">
                                    <p class="norm"><a id="jvms-5.4.6-100-B-A"></a>
                                        If <span class="type">C</span> contains a declaration of an instance method
                                        <code
                                                class="varname">m</code> that can
                                        override <code class="varname">m<sub>R</sub></code> (<a class="xref"
                                                                                                href="./jvms-5.html#jvms-5.4.5"
                                                                                                title="5.4.5. Method Overriding">5.4.5</a>),
                                        then <code class="varname">m</code> is
                                        the
                                        selected method.
                                    </p>
                                </li>
                                <li class="listitem">
                                    <p class="norm"><a id="jvms-5.4.6-100-B-B"></a>
                                        Otherwise, if <span class="type">C</span> has a superclass, a search for a
                                        declaration
                                        of an instance method that can override <code
                                                class="varname">m<sub>R</sub></code> is
                                        performed,
                                        starting with the direct superclass of <span class="type">C</span> and
                                        continuing with
                                        the direct superclass of that class, and so forth, until a
                                        method is found or no further superclasses exist. If a method
                                        is found, it is the selected method.
                                    </p>
                                </li>
                                <li class="listitem">
                                    <p class="norm"><a id="jvms-5.4.6-100-B-C"></a>
                                        Otherwise, the maximally-specific superinterface methods of <span
                                                class="type">C</span>
                                        are determined (<a class="xref"
                                                           href="./jvms-5.html#jvms-5.4.3.3"
                                                           title="5.4.3.3. Method Resolution">5.4.3.3</a>). If exactly
                                        one
                                        matches <code class="varname">m<sub>R</sub></code>'s name and descriptor and is
                                        not
                                        <code class="literal">abstract</code>,
                                        then it is the selected method.
                                    </p>
                                    <p class="note">Any maximally-specific superinterface method
                                        selected in this step can override <code class="varname">m<sub>R</sub></code>;
                                        there is
                                        no need to
                                        check this explicitly.
                                    </p>
                                </li>
                            </ul>
                        </div>
                    </li>
                </ol>
            </div>
            <p class="note">While <span class="type">C</span> will typically be a class, it may be an
                interface when these rules are applied during preparation
                (<a class="xref" href="./jvms-5.html#jvms-5.4.2"
                    title="5.4.2. Preparation">5.4.2</a>).
            </p>
        </div>
    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a id="jvms-5.5"></a>5.5. Initialization
                    </h2>
                </div>
            </div>
        </div>
        <p class="norm-dynamic"><a id="jvms-5.5-100"></a>
            <span class="emphasis"><em>Initialization</em></span> of a class or interface consists
            of executing its class or interface initialization method
            (<a class="xref" href="./jvms-2.html#jvms-2.9.2"
                title="2.9.2. Class Initialization Methods">2.9.2</a>).
        </p>
        <p class="norm-dynamic"><a id="jvms-5.5-110"></a>
            A class or interface <span class="type">C</span> may be initialized only as a result of:
        </p>
        <div class="norm">
            <ul class="norm" style="list-style-type: disc; ">
                <li class="listitem">
                    <p class="norm-dynamic"><a id="jvms-5.5-110-A"></a>
                        The execution of any one of the Java Virtual Machine instructions <span
                                class="emphasis"><em>new</em></span>,
                        <span class="emphasis"><em>getstatic</em></span>, <span
                                class="emphasis"><em>putstatic</em></span>,
                        or <span class="emphasis"><em>invokestatic</em></span> that references <span
                                class="type">C</span>
                        (<a class="xref"
                            href="./jvms-6.html#jvms-6.5.new"
                            title="new"><span class="emphasis"><em>new</em></span></a>,
                        <a class="xref"
                           href="./jvms-6.html#jvms-6.5.getstatic"
                           title="getstatic"><span class="emphasis"><em>getstatic</em></span></a>,
                        <a class="xref"
                           href="./jvms-6.html#jvms-6.5.putstatic"
                           title="putstatic"><span class="emphasis"><em>putstatic</em></span></a>,
                        <a class="xref"
                           href="./jvms-6.html#jvms-6.5.invokestatic"
                           title="invokestatic"><span class="emphasis"><em>invokestatic</em></span></a>).
                    </p>
                    <p class="norm-dynamic"><a id="jvms-5.5-110-A.1"></a>
                        Upon execution of a <span class="emphasis"><em>new</em></span> instruction, the class to be
                        initialized is the class referenced by the instruction.
                    </p>
                    <p class="norm-dynamic"><a id="jvms-5.5-110-A.2"></a>
                        Upon execution of a <span class="emphasis"><em>getstatic</em></span>, <span
                                class="emphasis"><em>putstatic</em></span>, or <span
                                class="emphasis"><em>invokestatic</em></span>
                        instruction, the class or interface to be initialized is the
                        class or interface that declares the resolved field or
                        method.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm-dynamic"><a id="jvms-5.5-110-B"></a>
                        The first invocation of a <code class="literal">java.lang.invoke.MethodHandle</code> instance
                        which
                        was the
                        result of method handle resolution
                        (<a class="xref"
                            href="./jvms-5.html#jvms-5.4.3.5"
                            title="5.4.3.5. Method Type and Method Handle Resolution">5.4.3.5</a>) for a method handle
                        of
                        kind 2
                        (<code class="literal">REF_getStatic</code>), 4 (<code class="literal">REF_putStatic</code>), 6
                        (<code class="literal">REF_invokeStatic</code>),
                        or 8 (<code class="literal">REF_newInvokeSpecial</code>).
                    </p>
                    <p class="note">
                        This implies that the class of a bootstrap method is initialized
                        when the bootstrap method is invoked for an <span class="emphasis"><em>invokedynamic</em></span>
                        instruction (<a class="xref"
                                        href="./jvms-6.html#jvms-6.5.invokedynamic"
                                        title="invokedynamic"><span class="emphasis"><em>invokedynamic</em></span></a>),
                        as part
                        of the continuing resolution of the call site specifier.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm-dynamic"><a id="jvms-5.5-110-C"></a>
                        Invocation of certain reflective methods in the class library
                        (<a class="xref" href="./jvms-2.html#jvms-2.12"
                            title="2.12. Class Libraries">2.12</a>), for example, in class <code
                                class="literal">Class</code> or
                        in package <code class="literal">java.lang.reflect</code>.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm-dynamic"><a id="jvms-5.5-110-D"></a>
                        If <span class="type">C</span> is a class, the initialization of one of its subclasses.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm-dynamic"><a id="jvms-5.5-110-E"></a>
                        If <span class="type">C</span> is an interface that declares a non-<code
                                class="literal">abstract</code>, non-<code class="literal">static</code> method,
                        the initialization of a class that implements <span class="type">C</span> directly or
                        indirectly.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm-dynamic"><a id="jvms-5.5-110-F"></a>
                        Its designation as the initial class or interface at Java Virtual Machine startup
                        (<a class="xref" href="./jvms-5.html#jvms-5.2"
                            title="5.2. Java Virtual Machine Startup">5.2</a>).
                    </p>
                </li>
            </ul>
        </div>
        <p class="norm-dynamic"><a id="jvms-5.5-120"></a>
            Prior to initialization, a class or interface must be linked, that is,
            verified, prepared, and optionally resolved.
        </p>
        <p class="norm-dynamic"><a id="jvms-5.5-200"></a>
            Because the Java Virtual Machine is multithreaded, initialization of a class or
            interface requires careful synchronization, since some other thread
            may be trying to initialize the same class or interface at the same
            time. There is also the possibility that initialization of a class or
            interface may be requested recursively as part of the initialization
            of that class or interface. The implementation of the Java Virtual Machine is
            responsible for taking care of synchronization and recursive
            initialization by using the following procedure. It assumes that the
            <code class="literal">Class</code> object has already been verified and prepared, and that the
            <code class="literal">Class</code> object contains state that indicates one of four
            situations:
        </p>
        <div class="norm">
            <ul class="norm" style="list-style-type: disc; ">
                <li class="listitem">
                    <p class="norm-dynamic"><a id="jvms-5.5-200-A"></a>
                        This <code class="literal">Class</code> object is verified and prepared but not
                        initialized.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm-dynamic"><a id="jvms-5.5-200-B"></a>
                        This <code class="literal">Class</code> object is being initialized by some particular
                        thread.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm-dynamic"><a id="jvms-5.5-200-C"></a>
                        This <code class="literal">Class</code> object is fully initialized and ready for
                        use.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm-dynamic"><a id="jvms-5.5-200-D"></a>
                        This <code class="literal">Class</code> object is in an erroneous state, perhaps because
                        initialization was attempted and failed.
                    </p>
                </li>
            </ul>
        </div>
        <p class="norm-dynamic"><a id="jvms-5.5-210"></a>
            For each class or interface <span class="type">C</span>, there is a unique initialization lock
            <code class="varname">LC</code>. The mapping from <span class="type">C</span> to <code
                    class="varname">LC</code> is left to the discretion of the
            Java Virtual Machine implementation. For example, <code class="varname">LC</code> could be the <code
                    class="literal">Class</code> object
            for <span class="type">C</span>, or the monitor associated with that <code class="literal">Class</code>
            object. The
            procedure for initializing <span class="type">C</span> is then as follows:
        </p>
        <div class="orderedlist">
            <ol class="orderedlist" type="1">
                <li class="listitem">
                    <p class="norm-dynamic"><a id="jvms-5.5-210-A"></a>
                        Synchronize on the initialization lock, <code class="varname">LC</code>, for <span
                                class="type">C</span>. This
                        involves waiting until the current thread can acquire
                        <code class="varname">LC</code>.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm-dynamic"><a id="jvms-5.5-210-B"></a>
                        If the <code class="literal">Class</code> object for <span class="type">C</span> indicates that
                        initialization is
                        in progress for <span class="type">C</span> by some other thread, then release <code
                                class="varname">LC</code> and
                        block the current thread until informed that the in-progress
                        initialization has completed, at which time repeat this
                        procedure.
                    </p>
                    <p class="norm-dynamic"><a id="jvms-5.5-210-B.1"></a>
                        Thread interrupt status is unaffected by execution of the
                        initialization procedure.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm-dynamic"><a id="jvms-5.5-210-C"></a>
                        If the <code class="literal">Class</code> object for <span class="type">C</span> indicates that
                        initialization is
                        in progress for <span class="type">C</span> by the current thread, then this must be a
                        recursive request for initialization. Release <code class="varname">LC</code> and complete
                        normally.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm-dynamic"><a id="jvms-5.5-210-D"></a>
                        If the <code class="literal">Class</code> object for <span class="type">C</span> indicates that
                        <span class="type">C</span> has already
                        been initialized, then no further action is required. Release
                        <code class="varname">LC</code> and complete normally.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm-error"><a id="jvms-5.5-210-E"></a>
                        If the <code class="literal">Class</code> object for <span class="type">C</span> is in an
                        erroneous
                        state, then
                        initialization is not possible. Release <code class="varname">LC</code> and throw a
                        <code class="literal">NoClassDefFoundError</code>.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm-dynamic"><a id="jvms-5.5-210-F"></a>
                        Otherwise, record the fact that initialization of the <code class="literal">Class</code>
                        object for <span class="type">C</span> is in progress by the current thread, and release
                        <code class="varname">LC</code>.
                    </p>
                    <p class="norm-dynamic"><a id="jvms-5.5-210-F.1"></a>
                        Then, initialize each <code class="literal">final</code> <code class="literal">static</code>
                        field
                        of <span class="type">C</span> with the
                        constant value in its <code class="literal">ConstantValue</code> attribute
                        (<a class="xref" href="./jvms-4.html#jvms-4.7.2"
                            title="4.7.2. The ConstantValue Attribute">4.7.2</a>), in the order the fields appear
                        in the <code class="literal">ClassFile</code> structure.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm-dynamic"><a id="jvms-5.5-210-G"></a>
                        Next, if <span class="type">C</span> is a class rather than an interface, then let <span
                                class="type">SC</span>
                        be its superclass and
                        let <span class="type">SI<sub>1</sub></span>,
                        ..., <span class="type">SI<sub>n</sub></span> be all
                        superinterfaces of <span class="type">C</span> (whether direct or indirect) that declare
                        at least one non-<code class="literal">abstract</code>, non-<code class="literal">static</code>
                        method. The order of
                        superinterfaces is given by a recursive enumeration over the
                        superinterface hierarchy of each interface directly implemented
                        by <span class="type">C</span>. For each interface <span class="type">I</span>
                        directly implemented by <span class="type">C</span> (in the order of
                        the <code class="literal">interfaces</code> array of <span class="type">C</span>), the
                        enumeration
                        recurs on <span class="type">I</span>'s superinterfaces (in the order of
                        the <code class="literal">interfaces</code> array of <span class="type">I</span>) before
                        returning
                        <span class="type">I</span>.
                    </p>
                    <p class="norm-dynamic"><a id="jvms-5.5-210-G.1"></a>
                        For each <span class="type">S</span> in the list [
                        <span class="type">SC</span>, <span class="type">SI<sub>1</sub></span>,
                        ..., <span class="type">SI<sub>n</sub></span> ], if <span class="type">S</span> has not
                        yet been initialized, then recursively perform this entire
                        procedure for <span class="type">S</span>. If necessary, verify and prepare <span
                                class="type">S</span>
                        first.
                    </p>
                    <p class="norm-error"><a id="jvms-5.5-210-G.2"></a>
                        If the initialization of <span class="type">S</span> completes abruptly because of a
                        thrown exception, then acquire <code class="varname">LC</code>, label the <code
                                class="literal">Class</code> object
                        for <span class="type">C</span> as erroneous, notify all waiting threads, release <code
                                class="varname">LC</code>,
                        and complete abruptly, throwing the same exception that resulted
                        from initializing <span class="type">SC</span>.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm-dynamic"><a id="jvms-5.5-210-H"></a>
                        Next, determine whether assertions are enabled for <span class="type">C</span> by querying
                        its defining loader.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm-dynamic"><a id="jvms-5.5-210-I"></a>
                        Next, execute the class or interface initialization method of
                        <span class="type">C</span>.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm-dynamic"><a id="jvms-5.5-210-J"></a>
                        If the execution of the class or interface initialization method
                        completes normally, then acquire <code class="varname">LC</code>, label the <code
                                class="literal">Class</code> object
                        for <span class="type">C</span> as fully initialized, notify all waiting threads,
                        release <code class="varname">LC</code>, and complete this procedure normally.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm-error"><a id="jvms-5.5-210-K"></a>
                        Otherwise, the class or interface initialization method must
                        have completed abruptly by throwing some exception <span class="type">E</span>. If the
                        class of <span class="type">E</span> is not <code class="literal">Error</code> or one of its
                        subclasses, then
                        create a new instance of the class <code class="literal">ExceptionInInitializerError</code>
                        with <span class="type">E</span> as the argument, and use this object in place of <span
                                class="type">E</span> in
                        the following step. If a new instance of
                        <code class="literal">ExceptionInInitializerError</code> cannot be created because an
                        <code class="literal">OutOfMemoryError</code> occurs, then use an <code
                                class="literal">OutOfMemoryError</code> object in place of <span class="type">E</span>
                        in the
                        following step.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm-error"><a id="jvms-5.5-210-L"></a>
                        Acquire <code class="varname">LC</code>, label the <code class="literal">Class</code> object for
                        <span class="type">C</span> as erroneous,
                        notify all waiting threads, release <code class="varname">LC</code>, and complete this
                        procedure abruptly with reason <span class="type">E</span> or its replacement as
                        determined in the previous step.
                    </p>
                </li>
            </ol>
        </div>
        <p class="norm"><a id="jvms-5.5-300"></a>A Java Virtual Machine implementation may
            optimize this procedure by eliding the lock acquisition in step 1 (and
            release in step 4/5) when it can determine that the initialization of
            the class has already completed, provided that, in terms of the Java
            memory model, all <span class="emphasis"><em>happens-before</em></span> orderings (JLS
            17.4.5) that would exist if the lock were acquired, still exist when
            the optimization is performed.
        </p>
    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a id="jvms-5.6"></a>5.6. Binding Native Method
                        Implementations
                    </h2>
                </div>
            </div>
        </div>
        <p class="norm"><a id="jvms-5.6-100"></a><span class="emphasis"><em>Binding</em></span>
            is the process by which a function written in a language other than
            the Java programming language and implementing a <code class="literal">native</code> method is integrated
            into
            the Java Virtual Machine so that it can be executed. Although this process is
            traditionally referred to as linking, the term binding is used in the
            specification to avoid confusion with linking of classes or interfaces
            by the Java Virtual Machine.
        </p>
    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a id="jvms-5.7"></a>5.7. Java Virtual Machine
                        Termination
                    </h2>
                </div>
            </div>
        </div>
        <p class="norm-dynamic"><a id="jvms-5.7-100"></a>
            The Java Virtual Machine executes code in threads (<a class="xref"
                                                                  href="./jvms-2.html#jvms-2.5"
                                                                  title="2.5. Run-Time Data Areas">2.5</a>). A
            thread is either a non-daemon thread, a daemon thread, or a shutdown
            hook.
        </p>
        <p class="note">Readers are referred to the API specifications of
            <code class="literal">Thread</code> and <code class="literal">Runtime</code> for details of how threads
            obtain daemon
            status, and how shutdown hooks are registered.
        </p>
        <p class="norm-dynamic"><a id="jvms-5.7-110"></a>
            A thread <span class="emphasis"><em>terminates</em></span> if either (i) its <code
                    class="literal">run</code>
            method completes normally, or (ii) its <code class="literal">run</code> method completes abruptly
            and the relevant uncaught exception handler (<a class="xref"
                                                            href="./jvms-2.html#jvms-2.10"
                                                            title="2.10. Exceptions">2.10</a>) completes normally or
            abruptly. With no code
            left to run, the thread has completed execution and therefore has no
            current method (<a class="xref"
                               href="./jvms-2.html#jvms-2.5.1"
                               title="2.5.1. The pc Register">2.5.1</a>).
        </p>
        <p class="norm-dynamic"><a id="jvms-5.7-200"></a>
            The Java Virtual Machine <span class="emphasis"><em>terminates</em></span> when one of the following
            situations has occurred:
        </p>
        <div class="orderedlist">
            <ol class="orderedlist" type="1">
                <li class="listitem">
                    <p class="norm-dynamic"><a id="jvms-5.7-200-A"></a>
                        A thread invoked <code class="literal">System.exit</code> or <code
                                class="literal">Runtime.exit</code>, and all of the
                        shutdown hooks which consequently were started by the Java Virtual Machine,
                        if any, have terminated.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm-dynamic"><a id="jvms-5.7-200-B"></a>
                        A thread invoked <code class="literal">Runtime.halt</code>. (No shutdown hooks are started in
                        this situation.)
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm-dynamic"><a id="jvms-5.7-200-C"></a>
                        The Java Virtual Machine implementation recognized an external event as requesting
                        termination of the Java Virtual Machine, and all of the shutdown hooks which
                        consequently were started by the Java Virtual Machine, if any, have terminated.
                    </p>
                    <p class="norm-dynamic"><a id="jvms-5.7-200-C.1"></a>
                        The nature of the event is outside the scope of this specification,
                        but is necessarily something that a Java Virtual Machine implementation can handle
                        reliably. An example is receiving a signal from the operating
                        system.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm-dynamic"><a id="jvms-5.7-200-D"></a>
                        An external event occurred that the Java Virtual Machine implementation cannot
                        handle. (No shutdown hooks are started in this situation.)
                    </p>
                    <p class="norm-dynamic"><a id="jvms-5.7-200-D.1"></a>
                        The nature of the event is outside the scope of this specification,
                        but is necessarily something that a Java Virtual Machine implementation cannot
                        recognize or recover from in any way. Examples include a fatal
                        error occurring in the process running the implementation, or
                        power being removed from the computer running the implementation.
                    </p>
                </li>
            </ol>
        </div>
        <p class="norm-dynamic"><a id="jvms-5.7-300"></a>
            Upon Java Virtual Machine termination, any daemon or non-daemon thread that has not yet
            terminated will execute no further Java code. The current method of the
            thread does not complete normally or abruptly.
        </p>
        <p class="norm-dynamic"><a id="jvms-5.7-310"></a>
            If the Java Virtual Machine terminates because a thread invoked <code class="literal">Runtime.halt</code>
            <span class="emphasis"><em>while shutdown hooks were running</em></span>, then, in
            addition to daemon and non-daemon threads, any shutdown hook that has
            not yet terminated will execute no further Java code.
        </p>
        <p class="note">Native applications can use the JNI Invocation API
            to create and destroy the Java Virtual Machine in such a way that a Java program,
            having started execution in the <code class="literal">main</code> method of an initial class (JLS
            12.1), exits when all of its non-daemon threads have terminated (JLS
            12.8). The Java Virtual Machine does not terminate "automatically" when the last
            non-daemon thread terminates.
        </p>
    </div>
</div>
<div class="navfooter">
    <hr/>
    <table width="100%" summary="Navigation footer">
        <tbody>
        <tr>
            <td width="40%" align="left"><a accesskey="p"
                                            href="./jvms-4.html">Prev</a>
            </td>
            <td width="20%" align="center"></td>
            <td width="40%" align="right"><a accesskey="n"
                                             href="./jvms-6.html">Next</a></td>
        </tr>
        <tr>
            <td width="40%" align="left" valign="top">Chapter 4. The <code class="literal">class</code>
                File Format
            </td>
            <td width="20%" align="center"><a accesskey="h"
                                              href="./index.html">Home</a></td>
            <td width="40%" align="right" valign="top"> Chapter 6. The Java Virtual Machine
                Instruction Set
            </td>
        </tr>
        </tbody>
    </table>
</div>


</body>

</html>